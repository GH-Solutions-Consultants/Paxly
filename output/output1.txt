package main

import (
	"github.com/GH-Solutions-Consultants/Paxly/cmd"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/go"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/javascript"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/python"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/rust"
)

func main() {
	cmd.Execute()
}
package main

import (
	"github.com/GH-Solutions-Consultants/Paxly/cmd"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/go"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/javascript"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/python"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/rust"
)

func main() {
	cmd.Execute()
}
// cmd/add.go
package cmd

import (
	"os"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v3"
)

var (
	addLanguage string
	addName     string
	addVersion  string
)

var addCmd = &cobra.Command{
	Use:   "add",
	Short: "Add a new dependency to the project",
	Run: func(cmd *cobra.Command, args []string) {
		// Read existing config
		data, err := os.ReadFile("pkgmgr.yaml")
		if err != nil {
			logrus.Fatalf("Failed to read pkgmgr.yaml: %v", err)
		}

		var config core.Config
		err = yaml.Unmarshal(data, &config)
		if err != nil {
			logrus.Fatalf("Failed to parse pkgmgr.yaml: %v", err)
		}

		// Validate inputs
		if addLanguage == "" || addName == "" || addVersion == "" {
			logrus.Fatal("Language, name, and version must be specified")
		}

		// Add dependency to the specified environment (defaulting to development)
		envConfig, exists := config.Environments["development"]
		if !exists {
			logrus.Fatal("Development environment not found in configuration")
		}

		dep := core.Dependency{
			Name:    addName,
			Version: addVersion,
		}

		envConfig.Dependencies[addLanguage] = append(envConfig.Dependencies[addLanguage], dep)
		config.Environments["development"] = envConfig

		// Marshal back to YAML
		newData, err := yaml.Marshal(&config)
		if err != nil {
			logrus.Fatalf("Failed to marshal updated configuration: %v", err)
		}

		// Write back to pkgmgr.yaml
		err = os.WriteFile("pkgmgr.yaml", newData, 0644)
		if err != nil {
			logrus.Fatalf("Failed to write updated pkgmgr.yaml: %v", err)
		}

		logrus.Infof("Added dependency '%s' version '%s' to language '%s' in development environment.", addName, addVersion, addLanguage)
	},
}

func init() {
	addCmd.Flags().StringVarP(&addLanguage, "language", "l", "", "Programming language of the dependency")
	addCmd.Flags().StringVarP(&addName, "name", "n", "", "Name of the dependency")
	addCmd.Flags().StringVarP(&addVersion, "version", "v", "", "Version constraint of the dependency")
	addCmd.MarkFlagRequired("language")
	addCmd.MarkFlagRequired("name")
	addCmd.MarkFlagRequired("version")

	rootCmd.AddCommand(addCmd)
}
// cmd/init.go
package cmd

import (
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
)

var (
	projectName        string
	projectVersion     string
	projectDescription string
	projectAuthors     []string
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize a new pkgmgr project",
	Run: func(cmd *cobra.Command, args []string) {
		err := core.InitializeProject(projectName, projectVersion, projectDescription, projectAuthors)
		if err != nil {
			cmd.PrintErrf("Failed to initialize project: %v\n", err)
			return
		}
	},
}

func init() {
	rootCmd.AddCommand(initCmd)

	initCmd.Flags().StringVarP(&projectName, "name", "n", "", "Name of the project")
	initCmd.Flags().StringVarP(&projectVersion, "version", "v", "1.0.0", "Version of the project")
	initCmd.Flags().StringVarP(&projectDescription, "description", "d", "", "Description of the project")
	initCmd.Flags().StringSliceVarP(&projectAuthors, "authors", "a", []string{}, "Authors of the project (format: 'Name <email>')")

	initCmd.MarkFlagRequired("name")
}
// cmd/install.go
package cmd

import (
	"os"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v2"
)

var env string

var installCmd = &cobra.Command{
	Use:   "install",
	Short: "Install all dependencies for the project",
	Run: func(cmd *cobra.Command, args []string) {
		// Read config
		data, err := os.ReadFile("pkgmgr.yaml")
		if err != nil {
			logrus.Fatal(errors.Wrap(err, "failed to read pkgmgr.yaml"))
		}

		var config core.Config
		err = yaml.Unmarshal(data, &config)
		if err != nil {
			logrus.Fatal(errors.Wrap(err, "failed to parse pkgmgr.yaml"))
		}

		// Validate configuration
		if err := config.Validate(); err != nil {
			logrus.Fatal(errors.Wrap(err, "configuration validation failed"))
		}

		// Initialize Resolver
		resolver := core.NewResolver(config, core.GetPluginRegistry())
		if err := resolver.ResolveDependencies(env); err != nil {
			logrus.Fatal(errors.Wrap(err, "dependency resolution failed"))
		}

		// Iterate over resolved dependencies and install via plugins
		envConfig, exists := config.Environments[env]
		if !exists {
			logrus.Fatal(errors.Errorf("specified environment '%s' does not exist", env))
		}

		for lang, deps := range envConfig.Dependencies {
			plugin, exists := core.GetPluginRegistry().GetPlugin(lang)
			if !exists {
				logrus.Warnf("No plugin found for language '%s'", lang)
				continue
			}
			if err := plugin.Install(deps); err != nil {
				logrus.Errorf("Failed to install dependencies for language '%s': %v", lang, err)
				logrus.Info("Ensure that the necessary package manager is installed and configured correctly.")
			}
		}

		logrus.Info("All dependencies installed successfully.")
	},
}

func init() {
	installCmd.Flags().StringVarP(&env, "env", "e", "development", "Specify the environment to use")
	rootCmd.AddCommand(installCmd)
}
// cmd/list.go
package cmd

import (
	"os"
	"log"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v2"
	"fmt"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all installed dependencies",
	Run: func(cmd *cobra.Command, args []string) {
		// Read config
		data, err := os.ReadFile("pkgmgr.yaml")
		if err != nil {
			log.Fatal(errors.Wrap(err, "failed to read pkgmgr.yaml"))
		}

		var config core.Config
		err = yaml.Unmarshal(data, &config)
		if err != nil {
			log.Fatal(errors.Wrap(err, "failed to parse pkgmgr.yaml"))
		}

		// Validate configuration
		if err := config.Validate(); err != nil {
			log.Fatal(errors.Wrap(err, "configuration validation failed"))
		}

		// Iterate over environments
		for envName, envConfig := range config.Environments {
			fmt.Printf("Environment: %s\n", envName)
			for lang, deps := range envConfig.Dependencies {
				fmt.Printf("  Language: %s\n", lang)
				fmt.Printf("  Dependencies: %v\n", deps)
				plugin, exists := core.GetPluginRegistry().GetPlugin(lang)
				if !exists {
					fmt.Printf("    No plugin found for language '%s'\n", lang)
					continue
				}
				installedDeps, err := plugin.List()
				if err != nil {
					fmt.Printf("    Failed to list dependencies for language '%s': %v\n", lang, err)
					continue
				}
				for _, dep := range installedDeps {
					fmt.Printf("    - %s: %s\n", dep.Name, dep.Version)
				}
			}
		}
	},
}

func init() {
	rootCmd.AddCommand(listCmd)
}
// cmd/remove.go
package cmd

import (
	"os"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v2"
)

var (
	removeLanguage string
	removeName     string
	removeCmd      = &cobra.Command{
		Use:   "remove",
		Short: "Remove a dependency from the project",
		Run: func(cmd *cobra.Command, args []string) {
			// Read config
			data, err := os.ReadFile("pkgmgr.yaml")
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to read pkgmgr.yaml"))
			}

			var config core.Config
			err = yaml.Unmarshal(data, &config)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to parse pkgmgr.yaml"))
			}

			// Validate configuration
			if err := config.Validate(); err != nil {
				logrus.Fatal(errors.Wrap(err, "configuration validation failed"))
			}

			// Remove dependency
			envConfig, exists := config.Environments["development"]
			if !exists {
				logrus.Fatal(errors.Errorf("environment 'development' does not exist"))
			}

			deps, exists := envConfig.Dependencies[removeLanguage]
			if !exists {
				logrus.Fatal(errors.Errorf("no dependencies found for language '%s'", removeLanguage))
			}

			index := -1
			for i, dep := range deps {
				if dep.Name == removeName {
					index = i
					break
				}
			}

			if index == -1 {
				logrus.Fatal(errors.Errorf("dependency '%s' not found in language '%s'", removeName, removeLanguage))
			}

			// Remove the dependency
			deps = append(deps[:index], deps[index+1:]...)
			config.Environments["development"].Dependencies[removeLanguage] = deps

			// Marshal back to YAML
			updatedData, err := yaml.Marshal(&config)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to marshal updated configuration"))
			}

			// Write back to pkgmgr.yaml
			err = os.WriteFile("pkgmgr.yaml", updatedData, 0644)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to write updated pkgmgr.yaml"))
			}

			logrus.Infof("Successfully removed dependency '%s' from language '%s'", removeName, removeLanguage)
		},
	}
)

func init() {
	rootCmd.AddCommand(removeCmd)

	removeCmd.Flags().StringVarP(&removeLanguage, "language", "l", "", "Programming language of the dependency")
	removeCmd.Flags().StringVarP(&removeName, "name", "n", "", "Name of the dependency")
	removeCmd.MarkFlagRequired("language")
	removeCmd.MarkFlagRequired("name")
}
// cmd/root.go
package cmd

import (
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
)

var (
	verbose bool
	debug   bool
	rootCmd = &cobra.Command{
		Use:   "pkgmgr",
		Short: "pkgmgr is a multi-language package manager",
		Long: `pkgmgr is a versatile package manager supporting multiple programming languages.
It allows you to manage dependencies across different languages seamlessly.`,
	}
)

// Execute runs the root command.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		logrus.Fatal(err)
	}
}

func init() {
	// Persistent flags apply to all subcommands.
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "Enable verbose output")
	rootCmd.PersistentFlags().BoolVarP(&debug, "debug", "d", false, "Enable debug output")
	rootCmd.PersistentPreRun = func(cmd *cobra.Command, args []string) {
		if debug {
			logrus.SetLevel(logrus.DebugLevel)
		} else if verbose {
			logrus.SetLevel(logrus.InfoLevel)
		} else {
			logrus.SetLevel(logrus.WarnLevel)
		}
	}
}
// cmd/update.go
package cmd

import (
	"os"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v2"
	"github.com/sirupsen/logrus"
)

var (
	updateLanguage string
	updateName     string
	updateVersion  string
	updateCmd      = &cobra.Command{
		Use:   "update",
		Short: "Update a dependency in the project",
		Run: func(cmd *cobra.Command, args []string) {
			// Read config
			data, err := os.ReadFile("pkgmgr.yaml")
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to read pkgmgr.yaml"))
			}

			var config core.Config
			err = yaml.Unmarshal(data, &config)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to parse pkgmgr.yaml"))
			}

			// Validate configuration
			if err := config.Validate(); err != nil {
				logrus.Fatal(errors.Wrap(err, "configuration validation failed"))
			}

			// Update dependency
			envConfig, exists := config.Environments["development"]
			if !exists {
				logrus.Fatal(errors.Errorf("environment 'development' does not exist"))
			}

			deps, exists := envConfig.Dependencies[updateLanguage]
			if !exists {
				logrus.Fatal(errors.Errorf("no dependencies found for language '%s'", updateLanguage))
			}

			found := false
			for i, dep := range deps {
				if dep.Name == updateName {
					deps[i].Version = updateVersion
					if err := deps[i].Validate(); err != nil {
						logrus.Fatal(errors.Wrap(err, "invalid version constraint"))
					}
					found = true
					break
				}
			}

			if !found {
				logrus.Fatal(errors.Errorf("dependency '%s' not found in language '%s'", updateName, updateLanguage))
			}

			config.Environments["development"].Dependencies[updateLanguage] = deps

			// Marshal back to YAML
			updatedData, err := yaml.Marshal(&config)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to marshal updated configuration"))
			}

			// Write back to pkgmgr.yaml
			err = os.WriteFile("pkgmgr.yaml", updatedData, 0644)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to write updated pkgmgr.yaml"))
			}
			logrus.Infof("Successfully updated dependency '%s' to version '%s' in language '%s'", updateName, updateVersion, updateLanguage)
		},
	}
)

func init() {
	rootCmd.AddCommand(updateCmd)

	updateCmd.Flags().StringVarP(&updateLanguage, "language", "l", "", "Programming language of the dependency")
	updateCmd.Flags().StringVarP(&updateName, "name", "n", "", "Name of the dependency")
	updateCmd.Flags().StringVarP(&updateVersion, "version", "v", "", "New version constraint of the dependency")
	updateCmd.MarkFlagRequired("language")
	updateCmd.MarkFlagRequired("name")
	updateCmd.MarkFlagRequired("version")
}
// core/cache.go
package core

import (
	"crypto/sha256"
	"fmt"
	"io"
	"os"
	"path/filepath"
)

// CacheDependency caches the downloaded package data.
func CacheDependency(dep Dependency, data io.Reader) error {
	cacheDir := "pkgmgr_cache"
	if _, err := os.Stat(cacheDir); os.IsNotExist(err) {
		if err := os.Mkdir(cacheDir, 0755); err != nil {
			return err
		}
	}

	hash := sha256.New()
	tee := io.TeeReader(data, hash)

	// Read the data to compute hash
	_, err := io.Copy(io.Discard, tee)
	if err != nil {
		return err
	}
	checksum := fmt.Sprintf("%x", hash.Sum(nil))

	// Create cache file path
	cachePath := filepath.Join(cacheDir, fmt.Sprintf("%s-%s.cache", dep.Name, checksum))
	if _, err := os.Stat(cachePath); err == nil {
		// Cached version exists
		return nil
	}

	// Save to cache
	file, err := os.Create(cachePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Reset the reader if possible or handle accordingly
	// This depends on how data is passed. If data is already consumed, consider reading from the original source again.

	return nil
}
// core/command.go
package core

import (
	"os/exec"
)

// Command represents an external command to be executed.
type Command struct {
	Name string
	Args []string
	// Optionally, you can add fields like Env, Dir, etc.
}

// Executor defines methods to execute commands.
type Executor interface {
	Run(cmd *Command) error
	Output(cmd *Command) ([]byte, error)
}

// RealExecutor is the default implementation of Executor using exec.Command.
type RealExecutor struct{}

func (e *RealExecutor) Run(cmd *Command) error {
	command := exec.Command(cmd.Name, cmd.Args...)
	command.Stdout = nil
	command.Stderr = nil
	return command.Run()
}

func (e *RealExecutor) Output(cmd *Command) ([]byte, error) {
	command := exec.Command(cmd.Name, cmd.Args...)
	return command.Output()
}
// core/config.go
package core

import (
	"fmt"

	"github.com/go-playground/validator/v10"
)

// Config represents the entire project configuration.
type Config struct {
	Project        ProjectConfig                `yaml:"project" validate:"required,dive"`
	Environments   map[string]EnvironmentConfig `yaml:"environments" validate:"required,dive"`
	TrustedSources map[string][]string          `yaml:"trusted_sources" validate:"required,dive,dive,uri"`
}

// EnvironmentConfig holds dependencies for a specific environment.
type EnvironmentConfig struct {
	Dependencies map[string][]Dependency `yaml:"dependencies" validate:"required,dive,dive"`
}

// ProjectConfig holds project metadata.
type ProjectConfig struct {
	Name        string   `yaml:"name" validate:"required"`
	Version     string   `yaml:"version" validate:"required,semver"`
	Description string   `yaml:"description"`
	Authors     []Author `yaml:"authors" validate:"dive"`
}

// Author represents a project author.
type Author struct {
	Name  string `yaml:"name" validate:"required"`
	Email string `yaml:"email" validate:"required,email"`
}

// Validate parses and validates the entire configuration.
func (c *Config) Validate() error {
	validate := validator.New()
	// Register custom validation
	validate.RegisterValidation("semver", validateSemVer)

	// Validate Project
	if err := validate.Struct(c.Project); err != nil {
		return err
	}

	// Validate Environments
	for envName, envConfig := range c.Environments {
		if err := validate.Struct(envConfig); err != nil {
			return fmt.Errorf("validation failed for environment '%s': %v", envName, err)
		}
		for lang, deps := range envConfig.Dependencies {
			for _, dep := range deps {
				if err := dep.Validate(); err != nil {
					return fmt.Errorf("invalid dependency '%s' in environment '%s', language '%s': %v", dep.Name, envName, lang, err)
				}
			}
		}
	}

	return nil
}
// core/constants.go
package core

const (
	PluginAPIVersion = "1.0.0"
	MaxConcurrency   = 5 // Adjust as needed
)
// core/dependency.go
package core

import (
	"fmt"

	"github.com/Masterminds/semver/v3"
	"github.com/go-playground/validator/v10"
)

// Dependency represents a package dependency.
type Dependency struct {
	Name       string              `yaml:"name" validate:"required"`
	Version    string              `yaml:"version" validate:"required"`
	Constraint *semver.Constraints `yaml:"-"`
}

// Validate parses and validates the dependency.
func (d *Dependency) Validate() error {
	validate := validator.New()
	// Register custom validation for semantic versioning
	validate.RegisterValidation("semver", validateSemVer)

	err := validate.Struct(d)
	if err != nil {
		return err
	}

	// Parse semantic version constraint
	constraint, err := semver.NewConstraint(d.Version)
	if err != nil {
		return fmt.Errorf("invalid version constraint '%s': %v", d.Version, err)
	}
	d.Constraint = constraint

	return nil
}

// validateSemVer ensures the version string adheres to semantic versioning.
func validateSemVer(fl validator.FieldLevel) bool {
	_, err := semver.NewConstraint(fl.Field().String())
	return err == nil
}
// core/logger.go
package core

import (
	"os"

	"github.com/sirupsen/logrus"
)

// InitializeLogger sets up the global logger.
func InitializeLogger() {
	logrus.SetFormatter(&logrus.TextFormatter{
		FullTimestamp: true,
	})
	logrus.SetOutput(os.Stdout)
	logrus.SetLevel(logrus.WarnLevel) // Default level
}

// LogFatal logs the error and exits the application.
func LogFatal(err error) {
	logrus.Fatal(err)
}
// core/plugin.go
package core

import (
	"fmt"
	"sync"
)

// PackageManagerPlugin defines the interface that all language-specific plugins must implement.
type PackageManagerPlugin interface {
	APIVersion() string
	Language() string
	Initialize(config Config) error
	Install(deps []Dependency) error
	Update(deps []Dependency) error
	Remove(dep Dependency) error
	List() ([]Dependency, error)
	ListVersions(depName string) ([]string, error)
	GetTransitiveDependencies(depName, version string) ([]Dependency, error)
	GetVulnerabilities() ([]SecurityVulnerability, error) // Newly added method
	Cleanup() error
}

// PluginRegistry manages all registered plugins.
type PluginRegistry struct {
	plugins map[string]PackageManagerPlugin
	mu      sync.RWMutex
}

// NewPluginRegistry creates a new PluginRegistry instance.
func NewPluginRegistry() *PluginRegistry {
	return &PluginRegistry{
		plugins: make(map[string]PackageManagerPlugin),
	}
}

// RegisterPlugin registers a new plugin.
func (pr *PluginRegistry) RegisterPlugin(plugin PackageManagerPlugin) error {
	pr.mu.Lock()
	defer pr.mu.Unlock()

	if plugin.APIVersion() != PluginAPIVersion {
		return fmt.Errorf("plugin %s has incompatible API version: got %s, expected %s",
			plugin.Language(), plugin.APIVersion(), PluginAPIVersion)
	}

	lang := plugin.Language()
	if _, exists := pr.plugins[lang]; exists {
		return fmt.Errorf("plugin for language '%s' is already registered", lang)
	}

	pr.plugins[lang] = plugin
	return nil
}

// GetPlugin retrieves a plugin by language.
func (pr *PluginRegistry) GetPlugin(lang string) (PackageManagerPlugin, bool) {
	pr.mu.RLock()
	defer pr.mu.RUnlock()

	plugin, exists := pr.plugins[lang]
	return plugin, exists
}

// GetAllPlugins retrieves all registered plugins.
func (pr *PluginRegistry) GetAllPlugins() map[string]PackageManagerPlugin {
	pr.mu.RLock()
	defer pr.mu.RUnlock()

	// Return a copy to prevent external modification
	pluginsCopy := make(map[string]PackageManagerPlugin)
	for lang, plugin := range pr.plugins {
		pluginsCopy[lang] = plugin
	}
	return pluginsCopy
}
// core/project.go
package core

import (
	"fmt"
	"os"
	"regexp"

	"gopkg.in/yaml.v2"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

// InitializeProject initializes a new pkgmgr project by creating a pkgmgr.yaml file.
func InitializeProject(name, version, description string, authors []string) error {
	if name == "" {
		return fmt.Errorf("project name is required")
	}

	authorStructs := []Author{}
	for _, authorStr := range authors {
		author, err := parseAuthor(authorStr)
		if err != nil {
			return errors.Wrapf(err, "invalid author format '%s'", authorStr)
		}
		authorStructs = append(authorStructs, author)
	}

	config := Config{
		Project: ProjectConfig{
			Name:        name,
			Version:     version,
			Description: description,
			Authors:     authorStructs,
		},
		Environments: map[string]EnvironmentConfig{
			"development": {
				Dependencies: map[string][]Dependency{},
			},
			"production": {
				Dependencies: map[string][]Dependency{},
			},
		},
		TrustedSources: map[string][]string{
			"python":      {"https://pypi.org/simple"},
			"javascript":  {"https://registry.npmjs.org/"},
			"go":          {"https://proxy.golang.org/"},
			"rust":        {"https://crates.io/"},
		},
	}

	data, err := yaml.Marshal(&config)
	if err != nil {
		return errors.Wrap(err, "failed to marshal configuration")
	}

	if _, err := os.Stat("pkgmgr.yaml"); err == nil {
		return fmt.Errorf("pkgmgr.yaml already exists")
	}

	err = os.WriteFile("pkgmgr.yaml", data, 0644)
	if err != nil {
		return errors.Wrap(err, "failed to write pkgmgr.yaml")
	}

	logrus.Info("Initialized pkgmgr project with pkgmgr.yaml")

	// Validate the config
	if err := config.Validate(); err != nil {
		return errors.Wrap(err, "configuration validation failed")
	}

	logrus.Info("Configuration validated successfully.")

	return nil
}

// parseAuthor parses a string in the format "Name <email>"
func parseAuthor(authorStr string) (Author, error) {
	re := regexp.MustCompile(`^(.*?)\s*<(.+)>$`)
	matches := re.FindStringSubmatch(authorStr)
	if len(matches) != 3 {
		return Author{}, fmt.Errorf("invalid author format")
	}
	return Author{
		Name:  matches[1],
		Email: matches[2],
	}, nil
}
// core/resolver.go
package core

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"sort"

	"github.com/Masterminds/semver/v3"
	"github.com/sirupsen/logrus"
)

// Resolver handles dependency resolution.
type Resolver struct {
	Config         Config
	PluginRegistry *PluginRegistry
	resolvedDeps   map[string]*semver.Version
	processingDeps map[string]bool // To detect cycles
}

// NewResolver creates a new Resolver instance.
func NewResolver(config Config, pr *PluginRegistry) *Resolver {
	return &Resolver{
		Config:         config,
		PluginRegistry: pr,
		resolvedDeps:   make(map[string]*semver.Version),
		processingDeps: make(map[string]bool),
	}
}

// ResolveDependencies resolves all dependencies recursively for a given environment.
func (r *Resolver) ResolveDependencies(env string) error {
	envConfig, exists := r.Config.Environments[env]
	if !exists {
		return fmt.Errorf("environment '%s' not found in configuration", env)
	}

	for lang, deps := range envConfig.Dependencies {
		for _, dep := range deps {
			if err := r.resolveDependency(lang, dep); err != nil {
				return err
			}
		}
	}

	return nil
}

// resolveDependency resolves a single dependency and its transitive dependencies.
func (r *Resolver) resolveDependency(lang string, dep Dependency) error {
	if err := dep.Validate(); err != nil {
		return fmt.Errorf("invalid dependency '%s' in language '%s': %v", dep.Name, lang, err)
	}

	// Check for cycles.
	if r.processingDeps[dep.Name] {
		return fmt.Errorf("cyclic dependency detected on '%s'", dep.Name)
	}

	// If already resolved, verify version compatibility.
	if existingVersion, exists := r.resolvedDeps[dep.Name]; exists {
		if !dep.Constraint.Check(existingVersion) {
			return fmt.Errorf("version conflict for '%s': existing version '%s' does not satisfy constraint '%s'", dep.Name, existingVersion, dep.Version)
		}
		return nil // Already resolved and compatible.
	}

	// Mark as processing.
	r.processingDeps[dep.Name] = true
	defer delete(r.processingDeps, dep.Name)

	// Fetch the latest compatible version.
	version, err := r.getLatestCompatibleVersion(lang, dep)
	if err != nil {
		return err
	}
	r.resolvedDeps[dep.Name] = version

	// Fetch transitive dependencies.
	transDeps, err := r.getTransitiveDependencies(lang, dep.Name, version)
	if err != nil {
		return err
	}

	// Recursively resolve transitive dependencies.
	for _, tDep := range transDeps {
		if err := r.resolveDependency(lang, tDep); err != nil {
			return err
		}
	}

	return nil
}

// getLatestCompatibleVersion retrieves the latest compatible version of a dependency.
func (r *Resolver) getLatestCompatibleVersion(lang string, dep Dependency) (*semver.Version, error) {
	plugin, exists := r.PluginRegistry.GetPlugin(lang)
	if !exists {
		return nil, fmt.Errorf("no plugin found for language '%s'", lang)
	}

	availableVersions, err := plugin.ListVersions(dep.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to list available versions for '%s': %v", dep.Name, err)
	}

	var compatibleVersions []*semver.Version
	for _, vStr := range availableVersions {
		v, err := semver.NewVersion(vStr)
		if err != nil {
			continue
		}
		if dep.Constraint.Check(v) {
			compatibleVersions = append(compatibleVersions, v)
		}
	}

	if len(compatibleVersions) == 0 {
		return nil, fmt.Errorf("no compatible versions found for '%s' with constraint '%s'", dep.Name, dep.Version)
	}

	// Sort the versions in ascending order and select the latest.
	sort.Slice(compatibleVersions, func(i, j int) bool {
		return compatibleVersions[i].LessThan(compatibleVersions[j])
	})
	latestVersion := compatibleVersions[len(compatibleVersions)-1]
	return latestVersion, nil
}

// getTransitiveDependencies fetches transitive dependencies for a given dependency.
func (r *Resolver) getTransitiveDependencies(lang, depName string, version *semver.Version) ([]Dependency, error) {
	plugin, exists := r.PluginRegistry.GetPlugin(lang)
	if !exists {
		return nil, fmt.Errorf("no plugin found for language '%s'", lang)
	}

	transDeps, err := plugin.GetTransitiveDependencies(depName, version.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get transitive dependencies for '%s@%s': %v", depName, version, err)
	}

	return transDeps, nil
}

// SecurityReport represents a security report for a language.
type SecurityReport struct {
	Language        string                 `json:"language"`
	Vulnerabilities []SecurityVulnerability `json:"vulnerabilities"`
}

// CollectSecurityReports collects security vulnerabilities from each plugin and generates reports.
func (r *Resolver) CollectSecurityReports() error {
	var securityReports []SecurityReport

	plugins := r.PluginRegistry.GetAllPlugins()
	for lang, plugin := range plugins {
		// Each plugin should expose a method to retrieve vulnerabilities
		vulns, err := plugin.GetVulnerabilities()
		if err != nil {
			logrus.Errorf("Failed to get vulnerabilities for '%s': %v", lang, err)
			continue
		}

		securityReports = append(securityReports, SecurityReport{
			Language:        lang,
			Vulnerabilities: vulns,
		})
	}

	// Generate security report in JSON
	if err := GenerateSecurityReport(securityReports, "json", "security_report.json"); err != nil {
		logrus.Errorf("Failed to generate JSON security report: %v", err)
		return err
	}

	// Generate security report in HTML
	if err := GenerateSecurityReport(securityReports, "html", "security_report.html"); err != nil {
		logrus.Errorf("Failed to generate HTML security report: %v", err)
		return err
	}

	return nil
}

// GenerateSecurityReport generates a security report in the specified format.
func GenerateSecurityReport(reports []SecurityReport, format, outputPath string) error {
	var data []byte
	var err error

	switch format {
	case "json":
		data, err = json.MarshalIndent(reports, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal security report to JSON: %v", err)
		}
	case "html":
		// Simple HTML template
		var buffer bytes.Buffer
		buffer.WriteString("<html><head><title>Security Report</title></head><body><h1>Security Report</h1>")
		for _, report := range reports {
			buffer.WriteString(fmt.Sprintf("<h2>%s</h2>", report.Language))
			if len(report.Vulnerabilities) == 0 {
				buffer.WriteString("<p>No vulnerabilities found.</p>")
				continue
			}
			buffer.WriteString("<ul>")
			for _, vuln := range report.Vulnerabilities {
				buffer.WriteString(fmt.Sprintf("<li><strong>%s:</strong> %s (Severity: %s)</li>", vuln.Package, vuln.Vulnerability, vuln.Severity))
			}
			buffer.WriteString("</ul>")
		}
		buffer.WriteString("</body></html>")
		data = buffer.Bytes()
	default:
		return fmt.Errorf("unsupported report format '%s'", format)
	}

	// Write to file
	if err := os.WriteFile(outputPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write security report to '%s': %v", outputPath, err)
	}

	logrus.Infof("Security report generated at '%s'", outputPath)
	return nil
}
// core/security.go
package core

// SecurityVulnerability represents a security issue found in a dependency.
type SecurityVulnerability struct {
	Package       string `json:"package"`
	Vulnerability string `json:"vulnerability"`
	Severity      string `json:"severity,omitempty"`
	Description   string `json:"description,omitempty"`
}
// core/utils.go
package core

import "runtime"

// IsWindows checks if the current OS is Windows.
func IsWindows() bool {
	return runtime.GOOS == "windows"
}
// plugins/go/go_plugin.go
package go_plugin

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/sirupsen/logrus"
)

// Ensure the GoPlugin implements the PackageManagerPlugin interface.
var _ core.PackageManagerPlugin = (*GoPlugin)(nil)

// GoPlugin is the plugin for managing Go dependencies.
type GoPlugin struct {
	executor core.Executor
}

// NewGoPlugin creates a new instance of GoPlugin with the given executor.
func NewGoPlugin(executor core.Executor) *GoPlugin {
	if executor == nil {
		executor = &core.RealExecutor{}
	}
	return &GoPlugin{
		executor: executor,
	}
}

// APIVersion returns the plugin API version.
func (p *GoPlugin) APIVersion() string {
	return core.PluginAPIVersion
}

// Language returns the name of the language this plugin manages.
func (p *GoPlugin) Language() string {
	return "go"
}

// Initialize sets up the Go plugin with necessary configurations.
func (p *GoPlugin) Initialize(config core.Config) error {
	logrus.Info("Initializing Go plugin...")
	// Validate Go installation
	if _, err := exec.LookPath("go"); err != nil {
		return fmt.Errorf("go is not installed or not in PATH")
	}
	// Ensure go.mod exists; if not, initialize it
	if _, err := os.Stat("go.mod"); os.IsNotExist(err) {
		logrus.Info("go.mod not found. Initializing Go module...")
		cmd := exec.Command("go", "mod", "init", config.Project.Name)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to initialize Go module: %v", err)
		}
	}
	return nil
}

// Install installs the specified Go dependencies.
func (p *GoPlugin) Install(deps []core.Dependency) error {
	for _, dep := range deps {
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Installing Go package")

		cmd := core.Command{
			Name: "go",
			Args: []string{"get", dep.Name},
		}
		err := p.executor.Run(&cmd)
		if err != nil {
			logrus.Errorf("Failed to install Go package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully installed Go package: %s", dep.Name)
	}

	// Run go mod tidy to clean up dependencies
	if err := p.runGoModTidy(); err != nil {
		logrus.Errorf("Failed to run 'go mod tidy': %v", err)
		return err
	}

	// Optionally, run security scans here if integrated

	return nil
}

// Update updates the specified Go dependencies.
func (p *GoPlugin) Update(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s@%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Updating Go package")

		cmd := core.Command{
			Name: "go",
			Args: []string{"get", "-u", pkgStr},
		}
		err := p.executor.Run(&cmd)
		if err != nil {
			logrus.Errorf("Failed to update Go package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully updated Go package: %s", dep.Name)
	}

	// Run go mod tidy to clean up dependencies
	if err := p.runGoModTidy(); err != nil {
		logrus.Errorf("Failed to run 'go mod tidy': %v", err)
		return err
	}

	return nil
}

// Remove removes the specified Go dependency.
func (p *GoPlugin) Remove(dep core.Dependency) error {
	pkgStr := dep.Name
	logrus.WithFields(logrus.Fields{
		"dependency": dep.Name,
	}).Info("Removing Go package")

	// To remove a dependency, we need to edit go.mod to remove the require directive
	// Since Go doesn't have a direct command to remove a module, we'll use 'go mod tidy' after manual removal

	// Remove the dependency from go.mod by running 'go mod edit -droprequire=dep.Name'
	cmd := core.Command{
		Name: "go",
		Args: []string{"mod", "edit", "-droprequire", dep.Name},
	}
	err := p.executor.Run(&cmd)
	if err != nil {
		logrus.Errorf("Failed to remove Go package '%s' from go.mod: %v", dep.Name, err)
		return err
	}

	// Run go mod tidy to clean up
	if err := p.runGoModTidy(); err != nil {
		logrus.Errorf("Failed to run 'go mod tidy' after removing package '%s': %v", dep.Name, err)
		return err
	}

	logrus.Infof("Successfully removed Go package: %s", dep.Name)
	return nil
}

// List lists all installed Go dependencies.
func (p *GoPlugin) List() ([]core.Dependency, error) {
	cmd := core.Command{
		Name: "go",
		Args: []string{"list", "-m", "all"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list Go modules: %v", err)
	}

	lines := strings.Split(string(output), "\n")
	deps := []core.Dependency{}
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Fields(line)
		if len(parts) < 2 {
			continue
		}
		deps = append(deps, core.Dependency{
			Name:    parts[0],
			Version: "=" + parts[1],
		})
	}

	return deps, nil
}

// ListVersions lists all available versions for a given Go dependency.
func (p *GoPlugin) ListVersions(depName string) ([]string, error) {
	cmd := core.Command{
		Name: "go",
		Args: []string{"list", "-m", "-versions", depName},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list versions for '%s': %v", depName, err)
	}

	parts := strings.Fields(string(output))
	if len(parts) < 2 {
		return nil, fmt.Errorf("no versions found for '%s'", depName)
	}

	versions := strings.Split(parts[1], " ")
	return versions, nil
}

// GetTransitiveDependencies fetches transitive dependencies for a given dependency.
func (p *GoPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	// Use 'go list -m -json all' to parse dependencies
	cmd := core.Command{
		Name: "go",
		Args: []string{"list", "-m", "-json", "all"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list modules for '%s': %v", depName, err)
	}

	var modules []map[string]interface{}
	dec := json.NewDecoder(bytes.NewReader(output))
	for {
		var m map[string]interface{}
		if err := dec.Decode(&m); err != nil {
			break
		}
		modules = append(modules, m)
	}

	transDeps := []core.Dependency{}
	for _, mod := range modules {
		if mod["Path"] == depName && mod["Version"] == version {
			if deps, ok := mod["Dependencies"].([]interface{}); ok {
				for _, d := range deps {
					if depMap, ok := d.(string); ok {
						parts := strings.Split(depMap, " ")
						if len(parts) >= 2 {
							transDeps = append(transDeps, core.Dependency{
								Name:    parts[0],
								Version: "=" + parts[1],
							})
						} else {
							transDeps = append(transDeps, core.Dependency{
								Name:    parts[0],
								Version: "",
							})
						}
					}
				}
			}
			break
		}
	}

	return transDeps, nil
}

// GetVulnerabilities retrieves security vulnerabilities using 'go list -m -json all' and an external tool.
func (p *GoPlugin) GetVulnerabilities() ([]core.SecurityVulnerability, error) {
	// Placeholder: Implement integration with a security tool like 'go-critic' or 'govulncheck'
	// For demonstration, we'll return an empty slice
	return []core.SecurityVulnerability{}, nil
}

// Cleanup performs any necessary cleanup operations.
func (p *GoPlugin) Cleanup() error {
	logrus.Info("Cleaning up Go plugin resources...")
	// Implement any necessary cleanup
	return nil
}

// runGoModTidy runs 'go mod tidy' to clean up dependencies.
func (p *GoPlugin) runGoModTidy() error {
	cmd := core.Command{
		Name: "go",
		Args: []string{"mod", "tidy"},
	}
	err := p.executor.Run(&cmd)
	if err != nil {
		return fmt.Errorf("failed to run 'go mod tidy': %v", err)
	}
	logrus.Info("Successfully ran 'go mod tidy'")
	return nil
}
// plugins/javascript/javascript_plugin.go
package javascript

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"

	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/sirupsen/logrus"
)

// Ensure the JavaScriptPlugin implements the PackageManagerPlugin interface.
var _ core.PackageManagerPlugin = (*JavaScriptPlugin)(nil)

// JavaScriptPlugin is the plugin for managing JavaScript dependencies.
type JavaScriptPlugin struct {
	executor core.Executor
}

// NewJavaScriptPlugin creates a new instance of JavaScriptPlugin with the given executor.
func NewJavaScriptPlugin(executor core.Executor) *JavaScriptPlugin {
	if executor == nil {
		executor = &core.RealExecutor{}
	}
	return &JavaScriptPlugin{
		executor: executor,
	}
}

// APIVersion returns the plugin API version.
func (p *JavaScriptPlugin) APIVersion() string {
	return core.PluginAPIVersion
}

// Language returns the name of the language this plugin manages.
func (p *JavaScriptPlugin) Language() string {
	return "javascript"
}

// Initialize sets up the JavaScript plugin with necessary configurations.
func (p *JavaScriptPlugin) Initialize(config core.Config) error {
	logrus.Info("Initializing JavaScript plugin...")
	// Validate npm installation
	if _, err := exec.LookPath("npm"); err != nil {
		return fmt.Errorf("npm is not installed or not in PATH")
	}
	// Ensure package.json exists; if not, initialize it
	if _, err := os.Stat("package.json"); os.IsNotExist(err) {
		logrus.Info("package.json not found. Initializing npm project...")
		cmd := exec.Command("npm", "init", "-y")
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to initialize npm project: %v", err)
		}
	}
	return nil
}

// Install installs the specified JavaScript dependencies.
func (p *JavaScriptPlugin) Install(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s@%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Installing JavaScript package")

		cmd := core.Command{
			Name: "npm",
			Args: []string{"install", pkgStr},
		}
		err := p.executor.Run(&cmd)
		if err != nil {
			logrus.Errorf("Failed to install JavaScript package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully installed JavaScript package: %s", dep.Name)
	}

	// Optionally, run 'npm audit' here if integrated

	return nil
}

// Update updates the specified JavaScript dependencies.
func (p *JavaScriptPlugin) Update(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s@%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Updating JavaScript package")

		cmd := core.Command{
			Name: "npm",
			Args: []string{"install", pkgStr},
		}
		err := p.executor.Run(&cmd)
		if err != nil {
			logrus.Errorf("Failed to update JavaScript package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully updated JavaScript package: %s", dep.Name)
	}

	return nil
}

// Remove removes the specified JavaScript dependency.
func (p *JavaScriptPlugin) Remove(dep core.Dependency) error {
	pkgStr := dep.Name
	logrus.WithFields(logrus.Fields{
		"dependency": dep.Name,
	}).Info("Removing JavaScript package")

	cmd := core.Command{
		Name: "npm",
		Args: []string{"uninstall", pkgStr},
	}
	err := p.executor.Run(&cmd)
	if err != nil {
		logrus.Errorf("Failed to remove JavaScript package '%s': %v", dep.Name, err)
		return err
	}

	logrus.Infof("Successfully removed JavaScript package: %s", dep.Name)
	return nil
}

// List lists all installed JavaScript dependencies.
func (p *JavaScriptPlugin) List() ([]core.Dependency, error) {
	cmd := core.Command{
		Name: "npm",
		Args: []string{"list", "--json", "--depth=0"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list JavaScript packages: %v", err)
	}

	var listOutput struct {
		Dependencies map[string]interface{} `json:"dependencies"`
	}

	if err := json.Unmarshal(output, &listOutput); err != nil {
		return nil, fmt.Errorf("failed to parse npm list output: %v", err)
	}

	deps := []core.Dependency{}
	for name, info := range listOutput.Dependencies {
		version, ok := info.(map[string]interface{})["version"].(string)
		if !ok {
			continue
		}
		deps = append(deps, core.Dependency{
			Name:    name,
			Version: "=" + version,
		})
	}

	return deps, nil
}

// ListVersions lists all available versions for a given JavaScript dependency.
func (p *JavaScriptPlugin) ListVersions(depName string) ([]string, error) {
	cmd := core.Command{
		Name: "npm",
		Args: []string{"view", depName, "versions", "--json"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list versions for '%s': %v", depName, err)
	}

	var versions []string
	if err := json.Unmarshal(output, &versions); err != nil {
		return nil, fmt.Errorf("failed to parse npm versions: %v", err)
	}

	return versions, nil
}

// GetTransitiveDependencies fetches transitive dependencies for a given dependency.
func (p *JavaScriptPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	// Use 'npm ls <depName> --json' to get dependencies
	cmd := core.Command{
		Name: "npm",
		Args: []string{"ls", depName, "--json"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list dependencies for '%s': %v", depName, err)
	}

	var lsOutput struct {
		Dependencies map[string]struct {
			Version       string                 `json:"version"`
			Dependencies  map[string]interface{} `json:"dependencies"`
			DevDependencies map[string]interface{} `json:"devDependencies"`
		} `json:"dependencies"`
	}

	if err := json.Unmarshal(output, &lsOutput); err != nil {
		return nil, fmt.Errorf("failed to parse npm ls output: %v", err)
	}

	transDeps := []core.Dependency{}
	if deps, ok := lsOutput.Dependencies[depName].Dependencies; ok {
		for name, info := range deps {
			version, ok := info.(map[string]interface{})["version"].(string)
			if !ok {
				continue
			}
			transDeps = append(transDeps, core.Dependency{
				Name:    name,
				Version: "=" + version,
			})
		}
	}

	return transDeps, nil
}

// GetVulnerabilities retrieves security vulnerabilities using 'npm audit --json'.
func (p *JavaScriptPlugin) GetVulnerabilities() ([]core.SecurityVulnerability, error) {
	cmd := core.Command{
		Name: "npm",
		Args: []string{"audit", "--json"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		// npm audit returns non-zero exit code if vulnerabilities are found
		// We still need to parse the output
		if exitErr, ok := err.(*exec.ExitError); ok {
			output = exitErr.Stderr
		} else {
			return nil, fmt.Errorf("failed to run npm audit: %v", err)
		}
	}

	var auditOutput struct {
		Vulnerabilities map[string]struct {
			Title       string `json:"title"`
			ModuleName  string `json:"module_name"`
			Severity    string `json:"severity"`
			Overview    string `json:"overview"`
			PatchedBy   []string `json:"patched_by"`
			Recommendation string `json:"recommendation"`
		} `json:"vulnerabilities"`
	}

	if err := json.Unmarshal(output, &auditOutput); err != nil {
		return nil, fmt.Errorf("failed to parse npm audit output: %v", err)
	}

	vulns := []core.SecurityVulnerability{}
	for _, vuln := range auditOutput.Vulnerabilities {
		vulns = append(vulns, core.SecurityVulnerability{
			Package:       vuln.ModuleName,
			Vulnerability: vuln.Title,
			Severity:      vuln.Severity,
			Description:   vuln.Overview,
		})
	}

	return vulns, nil
}

// Cleanup performs any necessary cleanup operations.
func (p *JavaScriptPlugin) Cleanup() error {
	logrus.Info("Cleaning up JavaScript plugin resources...")
	// Implement any necessary cleanup
	return nil
}
// plugins/python/python_plugin.go
package python

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"bytes"

	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/sirupsen/logrus"
)

// Ensure the PythonPlugin implements the PackageManagerPlugin interface.
var _ core.PackageManagerPlugin = (*PythonPlugin)(nil)

// PythonPlugin is the plugin for managing Python dependencies.
type PythonPlugin struct {
	executor core.Executor
}

// NewPythonPlugin creates a new instance of PythonPlugin with the given executor.
func NewPythonPlugin(executor core.Executor) *PythonPlugin {
	if executor == nil {
		executor = &core.RealExecutor{}
	}
	return &PythonPlugin{
		executor: executor,
	}
}

// APIVersion returns the plugin API version.
func (p *PythonPlugin) APIVersion() string {
	return core.PluginAPIVersion
}

// Language returns the name of the language this plugin manages.
func (p *PythonPlugin) Language() string {
	return "python"
}

// Initialize sets up the Python plugin with necessary configurations.
func (p *PythonPlugin) Initialize(config core.Config) error {
	logrus.Info("Initializing Python plugin...")
	// Validate Python installation
	if _, err := p.executor.Run(&core.Command{Name: "python3", Args: []string{"--version"}}); err != nil {
		return fmt.Errorf("python3 is not installed or not in PATH")
	}
	if _, err := p.executor.Run(&core.Command{Name: p.getPipPath(), Args: []string{"--version"}}); err != nil {
		return fmt.Errorf("pip is not installed or not in PATH")
	}
	// Ensure pipdeptree is installed
	if err := p.ensurePipDeptree(); err != nil {
		return err
	}
	return nil
}

// ensurePipDeptree ensures that pipdeptree is installed in the virtual environment.
func (p *PythonPlugin) ensurePipDeptree() error {
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"install", "pipdeptree"},
	}
	if err := p.executor.Run(cmd); err != nil {
		return fmt.Errorf("failed to install pipdeptree: %v", err)
	}
	return nil
}

// getPipPath returns the path to the pip executable, handling cross-platform paths.
func (p *PythonPlugin) getPipPath() string {
	if core.IsWindows() {
		return filepath.Join("venv", "Scripts", "pip.exe")
	}
	return filepath.Join("venv", "bin", "pip")
}

// Install installs the specified Python dependencies along with transitive dependencies.
func (p *PythonPlugin) Install(deps []core.Dependency) error {
	// Check if virtual environment exists.
	_, err := os.Stat("venv")
	if os.IsNotExist(err) {
		logrus.Info("Creating Python virtual environment...")
		cmd := &core.Command{
			Name: "python3",
			Args: []string{"-m", "venv", "venv"},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to create virtual environment: %v", err)
			return err
		}
	} else if err != nil {
		return fmt.Errorf("error checking virtual environment: %v", err)
	}

	// Install dependencies
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Installing Python package")

		cmd := &core.Command{
			Name: p.getPipPath(),
			Args: []string{"install", pkgStr},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to install Python package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully installed Python package: %s", dep.Name)

		// Resolve transitive dependencies.
		transDeps, err := p.GetTransitiveDependencies(dep.Name, dep.Constraint.String())
		if err != nil {
			logrus.Warnf("Failed to get transitive dependencies for '%s': %v", dep.Name, err)
			continue
		}
		if len(transDeps) > 0 {
			logrus.Infof("Resolving transitive dependencies for '%s'", dep.Name)
			if err := p.Install(transDeps); err != nil {
				logrus.Errorf("Failed to install transitive dependencies for '%s': %v", dep.Name, err)
			}
		}
	}

	// Run security scans after installation.
	if err := p.RunSecurityScan(); err != nil {
		logrus.Warnf("Security scan encountered issues: %v", err)
	}

	return nil
}

// Update updates the specified Python dependencies.
func (p *PythonPlugin) Update(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Updating Python package")

		cmd := &core.Command{
			Name: p.getPipPath(),
			Args: []string{"install", "--upgrade", pkgStr},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to update Python package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully updated Python package: %s", dep.Name)
	}

	// Run security scans after update.
	if err := p.RunSecurityScan(); err != nil {
		logrus.Warnf("Security scan encountered issues: %v", err)
	}

	return nil
}

// Remove removes the specified Python dependency.
func (p *PythonPlugin) Remove(dep core.Dependency) error {
	pkgStr := dep.Name
	logrus.WithFields(logrus.Fields{
		"dependency": dep.Name,
	}).Info("Removing Python package")

	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"uninstall", "-y", pkgStr},
	}
	if err := p.executor.Run(cmd); err != nil {
		logrus.Errorf("Failed to remove Python package '%s': %v", dep.Name, err)
		return err
	}
	logrus.Infof("Successfully removed Python package: %s", dep.Name)

	return nil
}

// List lists all installed Python dependencies.
func (p *PythonPlugin) List() ([]core.Dependency, error) {
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"freeze"},
	}
	output, err := p.executor.Output(cmd)
	if err != nil {
		return nil, err
	}

	deps := []core.Dependency{}
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Split(line, "==")
		if len(parts) != 2 {
			continue
		}
		deps = append(deps, core.Dependency{
			Name:    parts[0],
			Version: "=" + parts[1],
		})
	}

	return deps, nil
}

// ListVersions lists all available versions for a given Python package.
func (p *PythonPlugin) ListVersions(depName string) ([]string, error) {
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"install", fmt.Sprintf("%s==random", depName)}, // Intentional error to get available versions
	}
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	err := p.executor.Run(cmd)
	if err == nil {
		return nil, fmt.Errorf("expected failure when listing versions")
	}

	output := stderr.String()
	// Parse available versions from error message
	versions := []string{}
	prefix := "(from versions:"
	suffix := ")"
	start := strings.Index(output, prefix)
	if start == -1 {
		return nil, fmt.Errorf("failed to parse available versions")
	}
	start += len(prefix)
	end := strings.Index(output[start:], suffix)
	if end == -1 {
		return nil, fmt.Errorf("failed to parse available versions")
	}
	versionStr := output[start : start+end]
	versionParts := strings.Split(versionStr, ",")
	for _, v := range versionParts {
		v = strings.TrimSpace(v)
		versions = append(versions, v)
	}
	return versions, nil
}

// GetTransitiveDependencies fetches transitive dependencies for a given dependency.
func (p *PythonPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	cmd := &core.Command{
		Name: "pipdeptree",
		Args: []string{"--json-tree"},
	}
	output, err := p.executor.Output(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to run pipdeptree: %v", err)
	}

	var tree []map[string]interface{}
	if err := json.Unmarshal(output, &tree); err != nil {
		return nil, fmt.Errorf("failed to parse pipdeptree output: %v", err)
	}

	var transDeps []core.Dependency
	for _, pkg := range tree {
		if pkg["package"].(map[string]interface{})["name"] == depName {
			dependencies, ok := pkg["dependencies"].([]interface{})
			if !ok {
				continue
			}
			for _, d := range dependencies {
				depMap, ok := d.(map[string]interface{})
				if !ok {
					continue
				}
				name := depMap["package"].(map[string]interface{})["name"].(string)
				version := depMap["package"].(map[string]interface{})["version"].(string)
				transDeps = append(transDeps, core.Dependency{
					Name:    name,
					Version: "=" + version,
				})
			}
			break
		}
	}

	return transDeps, nil
}

// RunSecurityScan runs security scans on installed Python packages using 'safety'.
func (p *PythonPlugin) RunSecurityScan() error {
	logrus.Info("Running security scan on Python dependencies using 'safety'...")
	// Install safety if not installed
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"install", "safety"},
	}
	if err := p.executor.Run(cmd); err != nil {
		return fmt.Errorf("failed to install 'safety': %v", err)
	}

	// Run safety check
	scanCmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"run", "safety", "check", "--json"},
	}
	scanOutput, err := p.executor.Output(scanCmd)
	if err != nil {
		return fmt.Errorf("security scan failed: %v", err)
	}

	var scanResults []core.SecurityVulnerability
	if err := json.Unmarshal(scanOutput, &scanResults); err != nil {
		return fmt.Errorf("failed to parse security scan results: %v", err)
	}

	if len(scanResults) > 0 {
		logrus.Warn("Vulnerabilities detected in Python dependencies:")
		for _, vuln := range scanResults {
			logrus.Warnf("- %s: %s", vuln.Package, vuln.Vulnerability)
		}
	} else {
		logrus.Info("No vulnerabilities found in Python dependencies.")
	}

	return nil
}

// GetVulnerabilities retrieves security vulnerabilities.
func (p *PythonPlugin) GetVulnerabilities() ([]core.SecurityVulnerability, error) {
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"run", "safety", "check", "--json"},
	}
	scanOutput, err := p.executor.Output(cmd)
	if err != nil {
		return nil, fmt.Errorf("security scan failed: %v", err)
	}

	var scanResults []core.SecurityVulnerability
	if err := json.Unmarshal(scanOutput, &scanResults); err != nil {
		return nil, fmt.Errorf("failed to parse security scan results: %v", err)
	}

	return scanResults, nil
}

// Cleanup cleans up Python plugin resources.
func (p *PythonPlugin) Cleanup() error {
	logrus.Info("Cleaning up Python plugin resources...")
	// Implement any necessary cleanup, such as removing virtual environments
	// For example:
	// return os.RemoveAll("venv")
	return nil
}
// plugins/rust/rust_plugin.go
package rust

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/sirupsen/logrus"
)

// Ensure the RustPlugin implements the PackageManagerPlugin interface.
var _ core.PackageManagerPlugin = (*RustPlugin)(nil)

// RustPlugin is the plugin for managing Rust dependencies.
type RustPlugin struct {
	executor core.Executor
}

// NewRustPlugin creates a new instance of RustPlugin with the given executor.
func NewRustPlugin(executor core.Executor) *RustPlugin {
	if executor == nil {
		executor = &core.RealExecutor{}
	}
	return &RustPlugin{
		executor: executor,
	}
}

// APIVersion returns the plugin API version.
func (p *RustPlugin) APIVersion() string {
	return core.PluginAPIVersion
}

// Language returns the name of the language this plugin manages.
func (p *RustPlugin) Language() string {
	return "rust"
}

// Initialize sets up the Rust plugin with necessary configurations.
func (p *RustPlugin) Initialize(config core.Config) error {
	logrus.Info("Initializing Rust plugin...")
	// Validate cargo installation
	if _, err := p.executor.Run(&core.Command{Name: "cargo", Args: []string{"--version"}}); err != nil {
		return fmt.Errorf("cargo is not installed or not in PATH")
	}
	// Ensure cargo-edit is installed
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"install", "cargo-edit"},
	}
	if err := p.executor.Run(cmd); err != nil {
		return fmt.Errorf("failed to install cargo-edit: %v", err)
	}
	// Ensure Cargo.toml exists; if not, initialize it
	_, err := p.executor.Output(&core.Command{
		Name: "cargo",
		Args: []string{"metadata", "--format-version", "1"},
	})
	if err != nil {
		logrus.Info("Cargo.toml not found. Initializing Cargo project...")
		cmd := &core.Command{
			Name: "cargo",
			Args: []string{"init"},
		}
		if err := p.executor.Run(cmd); err != nil {
			return fmt.Errorf("failed to initialize Cargo project: %v", err)
		}
	}
	return nil
}

// Install installs the specified Rust dependencies.
func (p *RustPlugin) Install(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Installing Rust package")

		// Add dependency to Cargo.toml
		if err := p.addDependencyToCargoToml(dep); err != nil {
			logrus.Errorf("Failed to add Rust package '%s' to Cargo.toml: %v", dep.Name, err)
			return err
		}

		// Run cargo build to fetch dependencies
		cmd := &core.Command{
			Name: "cargo",
			Args: []string{"build"},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to build Rust project after adding package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully installed Rust package: %s", dep.Name)
	}

	// Run security scans after installation.
	if err := p.RunSecurityScan(); err != nil {
		logrus.Warnf("Security scan encountered issues: %v", err)
	}

	return nil
}

// Update updates the specified Rust dependencies.
func (p *RustPlugin) Update(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Updating Rust package")

		// Update dependency in Cargo.toml
		if err := p.updateDependencyInCargoToml(dep); err != nil {
			logrus.Errorf("Failed to update Rust package '%s' in Cargo.toml: %v", dep.Name, err)
			return err
		}

		// Run cargo update
		cmd := &core.Command{
			Name: "cargo",
			Args: []string{"update", "-p", dep.Name},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to update Rust package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully updated Rust package: %s", dep.Name)
	}

	// Run security scans after update.
	if err := p.RunSecurityScan(); err != nil {
		logrus.Warnf("Security scan encountered issues: %v", err)
	}

	return nil
}

// Remove removes the specified Rust dependency.
func (p *RustPlugin) Remove(dep core.Dependency) error {
	pkgStr := dep.Name
	logrus.WithFields(logrus.Fields{
		"dependency": dep.Name,
	}).Info("Removing Rust package")

	// Remove dependency from Cargo.toml
	if err := p.removeDependencyFromCargoToml(dep); err != nil {
		logrus.Errorf("Failed to remove Rust package '%s' from Cargo.toml: %v", dep.Name, err)
		return err
	}

	// Run cargo build to update dependencies
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"build"},
	}
	if err := p.executor.Run(cmd); err != nil {
		logrus.Errorf("Failed to build Rust project after removing package '%s': %v", dep.Name, err)
		return err
	}
	logrus.Infof("Successfully removed Rust package: %s", dep.Name)

	return nil
}

// List lists all installed Rust dependencies.
func (p *RustPlugin) List() ([]core.Dependency, error) {
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"tree", "--no-dev"},
	}
	output, err := p.executor.Output(cmd)
	if err != nil {
		return nil, err
	}

	// Parse the cargo tree output to list dependencies
	deps := []core.Dependency{}
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "├─") || strings.HasPrefix(line, "└─") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				pkgInfo := parts[1]
				pkgParts := strings.Split(pkgInfo, " ")
				if len(pkgParts) == 2 {
					deps = append(deps, core.Dependency{
						Name:    pkgParts[0],
						Version: "=" + pkgParts[1],
					})
				}
			}
		}
	}

	return deps, nil
}

// ListVersions lists all available versions for a given Rust package.
func (p *RustPlugin) ListVersions(depName string) ([]string, error) {
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"search", depName, "--limit", "100"},
	}
	output, err := p.executor.Output(cmd)
	if err != nil {
		return nil, err
	}

	// Parse cargo search output to get versions
	// Cargo search format: name = "description" [version]
	versions := []string{}
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.Contains(line, depName) {
			// Extract version using simple string manipulation
			parts := strings.Split(line, " ")
			for _, part := range parts {
				if strings.HasPrefix(part, "v") {
					versions = append(versions, part)
				}
			}
		}
	}

	return versions, nil
}

// GetTransitiveDependencies fetches transitive dependencies for a given dependency.
// Rust handles transitive dependencies automatically, so this can be a no-op.
func (p *RustPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	// Rust handles transitive dependencies automatically, so return nil
	return nil, nil
}

// RunSecurityScan runs security scans on installed Rust packages using 'cargo audit'.
func (p *RustPlugin) RunSecurityScan() error {
	logrus.Info("Running security scan on Rust dependencies using 'cargo audit'...")
	// Ensure cargo-audit is installed
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"install", "cargo-audit"},
	}
	if err := p.executor.Run(cmd); err != nil {
		return fmt.Errorf("failed to install cargo-audit: %v", err)
	}

	// Run cargo audit
	scanCmd := &core.Command{
		Name: "cargo",
		Args: []string{"audit", "--json"},
	}
	scanOutput, err := p.executor.Output(scanCmd)
	if err != nil {
		return fmt.Errorf("security scan failed: %v", err)
	}

	var auditResults []core.SecurityVulnerability
	if err := json.Unmarshal(scanOutput, &auditResults); err != nil {
		return fmt.Errorf("failed to parse cargo audit output: %v", err)
	}

	if len(auditResults) > 0 {
		logrus.Warn("Vulnerabilities detected in Rust dependencies:")
		for _, vuln := range auditResults {
			logrus.Warnf("- %s: %s", vuln.Package, vuln.Vulnerability)
		}
	} else {
		logrus.Info("No vulnerabilities found in Rust dependencies.")
	}

	return nil
}

// GetVulnerabilities retrieves security vulnerabilities.
func (p *RustPlugin) GetVulnerabilities() ([]core.SecurityVulnerability, error) {
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"audit", "--json"},
	}
	scanOutput, err := p.executor.Output(cmd)
	if err != nil {
		return nil, fmt.Errorf("security scan failed: %v", err)
	}

	var auditResults []core.SecurityVulnerability
	if err := json.Unmarshal(scanOutput, &auditResults); err != nil {
		return nil, fmt.Errorf("failed to parse cargo audit output: %v", err)
	}

	return auditResults, nil
}

// Cleanup cleans up Rust plugin resources.
func (p *RustPlugin) Cleanup() error {
	logrus.Info("Cleaning up Rust plugin resources...")
	// Implement any necessary cleanup
	return nil
}

// runGoModTidy runs 'go mod tidy' to clean up dependencies.
func (p *RustPlugin) runGoModTidy() error {
	cmd := &core.Command{
		Name: "go",
		Args: []string{"mod", "tidy"},
	}
	return p.executor.Run(cmd)
}

// addDependencyToCargoToml adds a dependency to Cargo.toml
func (p *RustPlugin) addDependencyToCargoToml(dep core.Dependency) error {
	// Add dependency using cargo-edit
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"add", fmt.Sprintf("%s=%s", dep.Name, strings.TrimPrefix(dep.Version, "^"))},
	}
	return p.executor.Run(cmd)
}

// updateDependencyInCargoToml updates a dependency in Cargo.toml
func (p *RustPlugin) updateDependencyInCargoToml(dep core.Dependency) error {
	// Update dependency using cargo-edit
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"upgrade", dep.Name},
	}
	return p.executor.Run(cmd)
}

// removeDependencyFromCargoToml removes a dependency from Cargo.toml
func (p *RustPlugin) removeDependencyFromCargoToml(dep core.Dependency) error {
	// Remove dependency using cargo-edit
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"remove", dep.Name},
	}
	return p.executor.Run(cmd)
}
// tests/core/config_test.go
package core_test

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/GH-Solutions-Consultants/Paxly/core"
)

func TestConfig_Validate_Success(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:        "TestProject",
			Version:     "1.0.0",
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "john.doe@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{
			"development": {
				Dependencies: map[string][]core.Dependency{
					"python": {
						{
							Name:    "requests",
							Version: "^2.28",
						},
					},
					"javascript": {
						{
							Name:    "express",
							Version: "^4.17.1",
						},
					},
				},
			},
			"production": {
				Dependencies: map[string][]core.Dependency{
					"python": {
						{
							Name:    "requests",
							Version: "^2.28",
						},
					},
					"javascript": {
						{
							Name:    "express",
							Version: "^4.17.1",
						},
					},
					"go": {
						{
							Name:    "github.com/gin-gonic/gin",
							Version: "^1.7.4",
						},
					},
					"rust": {
						{
							Name:    "serde",
							Version: "^1.0",
						},
					},
				},
			},
		},
		TrustedSources: map[string][]string{
			"python":      {"https://pypi.org/simple"},
			"javascript":  {"https://registry.npmjs.org/"},
			"go":          {"https://proxy.golang.org/"},
			"rust":        {"https://crates.io/"},
		},
	}

	err := config.Validate()
	assert.NoError(t, err, "Expected configuration to be valid")
}

func TestConfig_Validate_MissingProjectName(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			// Name is missing
			Version:     "1.0.0",
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "john.doe@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{},
		TrustedSources: map[string][]string{
			"python": {"https://pypi.org/simple"},
		},
	}

	err := config.Validate()
	assert.Error(t, err, "Expected configuration to fail validation due to missing project name")
}

func TestConfig_Validate_InvalidProjectVersion(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:        "TestProject",
			Version:     "invalid_version", // Invalid semantic version
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "john.doe@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{},
		TrustedSources: map[string][]string{
			"python": {"https://pypi.org/simple"},
		},
	}

	err := config.Validate()
	assert.Error(t, err, "Expected configuration to fail validation due to invalid project version")
}

func TestConfig_Validate_InvalidAuthorEmail(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:        "TestProject",
			Version:     "1.0.0",
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "invalid-email", // Invalid email format
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{},
		TrustedSources: map[string][]string{
			"python": {"https://pypi.org/simple"},
		},
	}

	err := config.Validate()
	assert.Error(t, err, "Expected configuration to fail validation due to invalid author email")
}

func TestConfig_Validate_InvalidTrustedSourceURL(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:        "TestProject",
			Version:     "1.0.0",
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "john.doe@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{},
		TrustedSources: map[string][]string{
			"python": {"invalid-url"}, // Invalid URL
		},
	}

	err := config.Validate()
	assert.Error(t, err, "Expected configuration to fail validation due to invalid trusted source URL")
}

func TestDependency_Validate_Success(t *testing.T) {
	dep := core.Dependency{
		Name:    "requests",
		Version: "^2.28",
	}

	err := dep.Validate()
	assert.NoError(t, err, "Expected dependency validation to pass")
	assert.NotNil(t, dep.Constraint, "Expected Constraint to be parsed")
}

func TestDependency_Validate_InvalidVersion(t *testing.T) {
	dep := core.Dependency{
		Name:    "requests",
		Version: "invalid_version",
	}

	err := dep.Validate()
	assert.Error(t, err, "Expected dependency validation to fail due to invalid version")
}

func TestDependency_Validate_MissingName(t *testing.T) {
	dep := core.Dependency{
		// Name is missing
		Version: "^2.28",
	}

	err := dep.Validate()
	assert.Error(t, err, "Expected dependency validation to fail due to missing name")
}

func TestDependency_Validate_MissingVersion(t *testing.T) {
	dep := core.Dependency{
		Name:    "requests",
		Version: "", // Missing version
	}

	err := dep.Validate()
	assert.Error(t, err, "Expected dependency validation to fail due to missing version")
}
// tests/core/resolver_test.go
package core_test

import (
	"testing"

	"github.com/go-playground/validator/v10"
	"github.com/stretchr/testify/assert"
	"github.com/GH-Solutions-Consultants/Paxly/core"
)

func TestResolver_ResolveDependencies_NoConflicts(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:    "TestProject",
			Version: "1.0.0",
			Authors: []core.Author{
				{
					Name:  "Tester",
					Email: "tester@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{
			"development": {
				Dependencies: map[string][]core.Dependency{
					"python": {
						{
							Name:    "requests",
							Version: "^2.28",
						},
					},
					"javascript": {
						{
							Name:    "express",
							Version: "^4.17.1",
						},
					},
				},
			},
		},
		TrustedSources: map[string][]string{
			"python":      {"https://pypi.org/simple"},
			"javascript":  {"https://registry.npmjs.org/"},
			"go":          {"https://proxy.golang.org/"},
			"rust":        {"https://crates.io/"},
		},
	}

	// Validate config
	validate := validator.New()
	err := validate.Struct(config)
	assert.NoError(t, err)

	// Initialize Plugin Registry with mock plugins
	pr := core.NewPluginRegistry()
	pr.RegisterPlugin(&MockPythonPlugin{})
	pr.RegisterPlugin(&MockJavaScriptPlugin{})

	// Initialize Resolver
	resolver := core.NewResolver(config, pr)
	resolvedVersions, err := resolver.ResolveDependencies("development")
	assert.NoError(t, err, "ResolveDependencies should not return an error")

	// Verify resolved dependencies
	expected := map[string]string{
		"requests": "2.28.1",
		"express":  "4.17.1",
	}
	for name, version := range expected {
		resolvedVersion, exists := resolvedVersions[name]
		assert.True(t, exists, "Dependency '%s' should be resolved", name)
		assert.Equal(t, version, resolvedVersion, "Version mismatch for '%s'", name)
	}
}

// Mock Plugins for Testing
type MockPythonPlugin struct{}

func (p *MockPythonPlugin) APIVersion() string        { return core.PluginAPIVersion }
func (p *MockPythonPlugin) Language() string          { return "python" }
func (p *MockPythonPlugin) Initialize(config core.Config) error { return nil }
func (p *MockPythonPlugin) Install(deps []core.Dependency) error { return nil }
func (p *MockPythonPlugin) Update(deps []core.Dependency) error { return nil }
func (p *MockPythonPlugin) Remove(dep core.Dependency) error { return nil }
func (p *MockPythonPlugin) List() ([]core.Dependency, error) { return nil, nil }
func (p *MockPythonPlugin) ListVersions(depName string) ([]string, error) {
	return []string{"2.28.0", "2.28.1"}, nil
}
func (p *MockPythonPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	return nil, nil
}
func (p *MockPythonPlugin) Cleanup() error { return nil }

type MockJavaScriptPlugin struct{}

func (p *MockJavaScriptPlugin) APIVersion() string        { return core.PluginAPIVersion }
func (p *MockJavaScriptPlugin) Language() string          { return "javascript" }
func (p *MockJavaScriptPlugin) Initialize(config core.Config) error { return nil }
func (p *MockJavaScriptPlugin) Install(deps []core.Dependency) error { return nil }
func (p *MockJavaScriptPlugin) Update(deps []core.Dependency) error { return nil }
func (p *MockJavaScriptPlugin) Remove(dep core.Dependency) error { return nil }
func (p *MockJavaScriptPlugin) List() ([]core.Dependency, error) { return nil, nil }
func (p *MockJavaScriptPlugin) ListVersions(depName string) ([]string, error) {
	return []string{"4.17.0", "4.17.1"}, nil
}
func (p *MockJavaScriptPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	return nil, nil
}
func (p *MockJavaScriptPlugin) Cleanup() error { return nil }
// tests/plugins/python_plugin_test.go
package plugins_test

import (
	"errors"
	"testing"
	"github.com/stretchr/testify/assert"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/GH-Solutions-Consultants/Paxly/plugins/python"

// MockExecutor is a mock for executing commands.
type MockExecutor struct {
	mock.Mock
}

func (m *MockExecutor) Run(cmd *core.Command) error {
	args := m.Called(cmd)
	return args.Error(0)
}

func (m *MockExecutor) Output(cmd *core.Command) ([]byte, error) {
	args := m.Called(cmd)
	return args.Get(0).([]byte), args.Error(1)
}

func TestPythonPlugin_Install_Success(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(nil).Twice() // create venv and install pipdeptree
	mockExec.On("Run", mock.Anything).Return(nil)            // pip install

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Define dependencies to install
	deps := []core.Dependency{
		{
			Name:    "requests",
			Version: "^2.28",
		},
	}

	// Execute Install
	err := plugin.Install(deps)
	assert.NoError(t, err, "Expected Install to succeed")

	// Assert that Run was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_Install_Failure(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(errors.New("pip install failed"))

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Define dependencies to install
	deps := []core.Dependency{
		{
			Name:    "requests",
			Version: "^2.28",
		},
	}

	// Execute Install
	err := plugin.Install(deps)
	assert.Error(t, err, "Expected Install to fail")

	// Assert that Run was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_List_Success(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Sample pip freeze output
	pipFreezeOutput := []byte("requests==2.28.1\nflask==1.1.2\n")

	// Setup expected commands and their outcomes
	mockExec.On("Output", mock.Anything).Return(pipFreezeOutput, nil)

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute List
	deps, err := plugin.List()
	assert.NoError(t, err, "Expected List to succeed")
	assert.Len(t, deps, 2, "Expected two dependencies listed")

	assert.Equal(t, "requests", deps[0].Name)
	assert.Equal(t, "=2.28.1", deps[0].Version)

	assert.Equal(t, "flask", deps[1].Name)
	assert.Equal(t, "=1.1.2", deps[1].Version)

	// Assert that Output was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_List_Failure(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Setup expected commands and their outcomes
	mockExec.On("Output", mock.Anything).Return(nil, errors.New("pip freeze failed"))

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute List
	deps, err := plugin.List()
	assert.Error(t, err, "Expected List to fail")
	assert.Nil(t, deps, "Expected no dependencies returned on failure")

	// Assert that Output was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_ListVersions_Success(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Mocked available versions
	availableVersions := []string{"2.25.0", "2.25.1", "2.26.0", "2.28.1"}

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(nil) // pip install failed as expected
	mockExec.On("Run", mock.Anything).Return(nil)
	mockExec.On("Output", mock.Anything).Return([]byte{}, nil) // Simplified

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute ListVersions
	versions, err := plugin.ListVersions("requests")
	assert.NoError(t, err, "Expected ListVersions to succeed")
	assert.Equal(t, availableVersions, versions, "Expected list of available versions")

	// Assert that Run was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_GetTransitiveDependencies_Success(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Sample pipdeptree JSON output
	pipDeptreeOutput := []byte(`[
		{
			"package": {"key": "requests", "name": "requests", "version": "2.28.1"},
			"dependencies": [
				{
					"package": {"key": "urllib3", "name": "urllib3", "version": "1.26.5"},
					"dependencies": []
				}
			]
		}
	]`)

	// Setup expected commands and their outcomes
	mockExec.On("Output", mock.Anything).Return(pipDeptreeOutput, nil)

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute GetTransitiveDependencies
	transDeps, err := plugin.GetTransitiveDependencies("requests", "^2.28")
	assert.NoError(t, err, "Expected GetTransitiveDependencies to succeed")
	assert.Len(t, transDeps, 1, "Expected one transitive dependency")

	assert.Equal(t, "urllib3", transDeps[0].Name)
	assert.Equal(t, "=1.26.5", transDeps[0].Version)

	// Assert that Output was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_RunSecurityScan_NoVulnerabilities(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Sample safety check output with no vulnerabilities
	safetyOutput := []byte("[]")

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(nil).Twice() // pip install safety and run safety check
	mockExec.On("Output", mock.Anything).Return(safetyOutput, nil)

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute RunSecurityScan
	err := plugin.RunSecurityScan()
	assert.NoError(t, err, "Expected RunSecurityScan to pass with no vulnerabilities")

	// Assert that Run and Output were called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_RunSecurityScan_WithVulnerabilities(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Sample safety check output with vulnerabilities
	safetyOutput := []byte(`[{"package": "requests", "vulnerability": "CVE-XXXX-XXXX"}]`)

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(nil).Twice() // pip install safety and run safety check
	mockExec.On("Output", mock.Anything).Return(safetyOutput, nil)

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute RunSecurityScan
	err := plugin.RunSecurityScan()
	assert.NoError(t, err, "Expected RunSecurityScan to complete even with vulnerabilities")

	// Assert that Run and Output were called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_RunSecurityScan_Failure(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(errors.New("safety install failed"))

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute RunSecurityScan
	err := plugin.RunSecurityScan()
	assert.Error(t, err, "Expected RunSecurityScan to fail due to safety install error")

	// Assert that Run was called
	mockExec.AssertExpectations(t)
}
package main

import (
	"github.com/GH-Solutions-Consultants/Paxly/cmd"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/go"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/javascript"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/python"
	_ "github.com/GH-Solutions-Consultants/Paxly/plugins/rust"
)

func main() {
	cmd.Execute()
}
// cmd/add.go
package cmd

import (
	"os"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v3"
)

var (
	addLanguage string
	addName     string
	addVersion  string
)

var addCmd = &cobra.Command{
	Use:   "add",
	Short: "Add a new dependency to the project",
	Run: func(cmd *cobra.Command, args []string) {
		// Read existing config
		data, err := os.ReadFile("pkgmgr.yaml")
		if err != nil {
			logrus.Fatalf("Failed to read pkgmgr.yaml: %v", err)
		}

		var config core.Config
		err = yaml.Unmarshal(data, &config)
		if err != nil {
			logrus.Fatalf("Failed to parse pkgmgr.yaml: %v", err)
		}

		// Validate inputs
		if addLanguage == "" || addName == "" || addVersion == "" {
			logrus.Fatal("Language, name, and version must be specified")
		}

		// Add dependency to the specified environment (defaulting to development)
		envConfig, exists := config.Environments["development"]
		if !exists {
			logrus.Fatal("Development environment not found in configuration")
		}

		dep := core.Dependency{
			Name:    addName,
			Version: addVersion,
		}

		envConfig.Dependencies[addLanguage] = append(envConfig.Dependencies[addLanguage], dep)
		config.Environments["development"] = envConfig

		// Marshal back to YAML
		newData, err := yaml.Marshal(&config)
		if err != nil {
			logrus.Fatalf("Failed to marshal updated configuration: %v", err)
		}

		// Write back to pkgmgr.yaml
		err = os.WriteFile("pkgmgr.yaml", newData, 0644)
		if err != nil {
			logrus.Fatalf("Failed to write updated pkgmgr.yaml: %v", err)
		}

		logrus.Infof("Added dependency '%s' version '%s' to language '%s' in development environment.", addName, addVersion, addLanguage)
	},
}

func init() {
	addCmd.Flags().StringVarP(&addLanguage, "language", "l", "", "Programming language of the dependency")
	addCmd.Flags().StringVarP(&addName, "name", "n", "", "Name of the dependency")
	addCmd.Flags().StringVarP(&addVersion, "version", "v", "", "Version constraint of the dependency")
	addCmd.MarkFlagRequired("language")
	addCmd.MarkFlagRequired("name")
	addCmd.MarkFlagRequired("version")

	rootCmd.AddCommand(addCmd)
}
// cmd/init.go
package cmd

import (
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
)

var (
	projectName        string
	projectVersion     string
	projectDescription string
	projectAuthors     []string
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize a new pkgmgr project",
	Run: func(cmd *cobra.Command, args []string) {
		err := core.InitializeProject(projectName, projectVersion, projectDescription, projectAuthors)
		if err != nil {
			cmd.PrintErrf("Failed to initialize project: %v\n", err)
			return
		}
	},
}

func init() {
	rootCmd.AddCommand(initCmd)

	initCmd.Flags().StringVarP(&projectName, "name", "n", "", "Name of the project")
	initCmd.Flags().StringVarP(&projectVersion, "version", "v", "1.0.0", "Version of the project")
	initCmd.Flags().StringVarP(&projectDescription, "description", "d", "", "Description of the project")
	initCmd.Flags().StringSliceVarP(&projectAuthors, "authors", "a", []string{}, "Authors of the project (format: 'Name <email>')")

	initCmd.MarkFlagRequired("name")
}
// cmd/install.go
package cmd

import (
	"os"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v2"
)

var env string

var installCmd = &cobra.Command{
	Use:   "install",
	Short: "Install all dependencies for the project",
	Run: func(cmd *cobra.Command, args []string) {
		// Read config
		data, err := os.ReadFile("pkgmgr.yaml")
		if err != nil {
			logrus.Fatal(errors.Wrap(err, "failed to read pkgmgr.yaml"))
		}

		var config core.Config
		err = yaml.Unmarshal(data, &config)
		if err != nil {
			logrus.Fatal(errors.Wrap(err, "failed to parse pkgmgr.yaml"))
		}

		// Validate configuration
		if err := config.Validate(); err != nil {
			logrus.Fatal(errors.Wrap(err, "configuration validation failed"))
		}

		// Initialize Resolver
		resolver := core.NewResolver(config, core.GetPluginRegistry())
		if err := resolver.ResolveDependencies(env); err != nil {
			logrus.Fatal(errors.Wrap(err, "dependency resolution failed"))
		}

		// Iterate over resolved dependencies and install via plugins
		envConfig, exists := config.Environments[env]
		if !exists {
			logrus.Fatal(errors.Errorf("specified environment '%s' does not exist", env))
		}

		for lang, deps := range envConfig.Dependencies {
			plugin, exists := core.GetPluginRegistry().GetPlugin(lang)
			if !exists {
				logrus.Warnf("No plugin found for language '%s'", lang)
				continue
			}
			if err := plugin.Install(deps); err != nil {
				logrus.Errorf("Failed to install dependencies for language '%s': %v", lang, err)
				logrus.Info("Ensure that the necessary package manager is installed and configured correctly.")
			}
		}

		logrus.Info("All dependencies installed successfully.")
	},
}

func init() {
	installCmd.Flags().StringVarP(&env, "env", "e", "development", "Specify the environment to use")
	rootCmd.AddCommand(installCmd)
}
// cmd/list.go
package cmd

import (
	"fmt"
	"os"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v2"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all installed dependencies",
	Run: func(cmd *cobra.Command, args []string) {
		// Read config
		data, err := os.ReadFile("pkgmgr.yaml")
		if err != nil {
			logrus.Fatal(errors.Wrap(err, "failed to read pkgmgr.yaml"))
		}

		var config core.Config
		err = yaml.Unmarshal(data, &config)
		if err != nil {
			logrus.Fatal(errors.Wrap(err, "failed to parse pkgmgr.yaml"))
		}

		// Validate configuration
		if err := config.Validate(); err != nil {
			logrus.Fatal(errors.Wrap(err, "configuration validation failed"))
		}

		// Iterate over environments
		for envName, envConfig := range config.Environments {
			fmt.Printf("Environment: %s\n", envName)
			for lang, deps := range envConfig.Dependencies {
				fmt.Printf("  Language: %s\n", lang)
				fmt.Printf("  Dependencies: %v\n", deps)
				plugin, exists := core.GetPluginRegistry().GetPlugin(lang)
				if !exists {
					fmt.Printf("    No plugin found for language '%s'\n", lang)
					continue
				}
				installedDeps, err := plugin.List()
				if err != nil {
					fmt.Printf("    Failed to list dependencies for language '%s': %v\n", lang, err)
					continue
				}
				for _, dep := range installedDeps {
					fmt.Printf("    - %s: %s\n", dep.Name, dep.Version)
				}
			}
		}
	},
}

func init() {
	rootCmd.AddCommand(listCmd)
}
// cmd/remove.go
package cmd

import (
	"os"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v2"
)

var (
	removeLanguage string
	removeName     string
	removeCmd      = &cobra.Command{
		Use:   "remove",
		Short: "Remove a dependency from the project",
		Run: func(cmd *cobra.Command, args []string) {
			// Read config
			data, err := os.ReadFile("pkgmgr.yaml")
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to read pkgmgr.yaml"))
			}

			var config core.Config
			err = yaml.Unmarshal(data, &config)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to parse pkgmgr.yaml"))
			}

			// Validate configuration
			if err := config.Validate(); err != nil {
				logrus.Fatal(errors.Wrap(err, "configuration validation failed"))
			}

			// Remove dependency
			envConfig, exists := config.Environments["development"]
			if !exists {
				logrus.Fatal(errors.Errorf("environment 'development' does not exist"))
			}

			deps, exists := envConfig.Dependencies[removeLanguage]
			if !exists {
				logrus.Fatal(errors.Errorf("no dependencies found for language '%s'", removeLanguage))
			}

			index := -1
			for i, dep := range deps {
				if dep.Name == removeName {
					index = i
					break
				}
			}

			if index == -1 {
				logrus.Fatal(errors.Errorf("dependency '%s' not found in language '%s'", removeName, removeLanguage))
			}

			// Remove the dependency
			deps = append(deps[:index], deps[index+1:]...)
			config.Environments["development"].Dependencies[removeLanguage] = deps

			// Marshal back to YAML
			updatedData, err := yaml.Marshal(&config)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to marshal updated configuration"))
			}

			// Write back to pkgmgr.yaml
			err = os.WriteFile("pkgmgr.yaml", updatedData, 0644)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to write updated pkgmgr.yaml"))
			}

			logrus.Infof("Successfully removed dependency '%s' from language '%s'", removeName, removeLanguage)
		},
	}
)

func init() {
	rootCmd.AddCommand(removeCmd)

	removeCmd.Flags().StringVarP(&removeLanguage, "language", "l", "", "Programming language of the dependency")
	removeCmd.Flags().StringVarP(&removeName, "name", "n", "", "Name of the dependency")
	removeCmd.MarkFlagRequired("language")
	removeCmd.MarkFlagRequired("name")
}
// cmd/root.go
package cmd

import (
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
)

var (
	verbose bool
	debug   bool
	rootCmd = &cobra.Command{
		Use:   "pkgmgr",
		Short: "pkgmgr is a multi-language package manager",
		Long: `pkgmgr is a versatile package manager supporting multiple programming languages.
It allows you to manage dependencies across different languages seamlessly.`,
	}
)

// Execute runs the root command.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		logrus.Fatal(err)
	}
}

func init() {
	// Persistent flags apply to all subcommands.
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "Enable verbose output")
	rootCmd.PersistentFlags().BoolVarP(&debug, "debug", "d", false, "Enable debug output")
	rootCmd.PersistentPreRun = func(cmd *cobra.Command, args []string) {
		if debug {
			logrus.SetLevel(logrus.DebugLevel)
		} else if verbose {
			logrus.SetLevel(logrus.InfoLevel)
		} else {
			logrus.SetLevel(logrus.WarnLevel)
		}
	}
}
// cmd/update.go
package cmd

import (
	"os"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"gopkg.in/yaml.v2"
	"github.com/sirupsen/logrus"
)

var (
	updateLanguage string
	updateName     string
	updateVersion  string
	updateCmd      = &cobra.Command{
		Use:   "update",
		Short: "Update a dependency in the project",
		Run: func(cmd *cobra.Command, args []string) {
			// Read config
			data, err := os.ReadFile("pkgmgr.yaml")
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to read pkgmgr.yaml"))
			}

			var config core.Config
			err = yaml.Unmarshal(data, &config)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to parse pkgmgr.yaml"))
			}

			// Validate configuration
			if err := config.Validate(); err != nil {
				logrus.Fatal(errors.Wrap(err, "configuration validation failed"))
			}

			// Update dependency
			envConfig, exists := config.Environments["development"]
			if !exists {
				logrus.Fatal(errors.Errorf("environment 'development' does not exist"))
			}

			deps, exists := envConfig.Dependencies[updateLanguage]
			if !exists {
				logrus.Fatal(errors.Errorf("no dependencies found for language '%s'", updateLanguage))
			}

			found := false
			for i, dep := range deps {
				if dep.Name == updateName {
					deps[i].Version = updateVersion
					if err := deps[i].Validate(); err != nil {
						logrus.Fatal(errors.Wrap(err, "invalid version constraint"))
					}
					found = true
					break
				}
			}

			if !found {
				logrus.Fatal(errors.Errorf("dependency '%s' not found in language '%s'", updateName, updateLanguage))
			}

			config.Environments["development"].Dependencies[updateLanguage] = deps

			// Marshal back to YAML
			updatedData, err := yaml.Marshal(&config)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to marshal updated configuration"))
			}

			// Write back to pkgmgr.yaml
			err = os.WriteFile("pkgmgr.yaml", updatedData, 0644)
			if err != nil {
				logrus.Fatal(errors.Wrap(err, "failed to write updated pkgmgr.yaml"))
			}
			logrus.Infof("Successfully updated dependency '%s' to version '%s' in language '%s'", updateName, updateVersion, updateLanguage)
		},
	}
)

func init() {
	rootCmd.AddCommand(updateCmd)

	updateCmd.Flags().StringVarP(&updateLanguage, "language", "l", "", "Programming language of the dependency")
	updateCmd.Flags().StringVarP(&updateName, "name", "n", "", "Name of the dependency")
	updateCmd.Flags().StringVarP(&updateVersion, "version", "v", "", "New version constraint of the dependency")
	updateCmd.MarkFlagRequired("language")
	updateCmd.MarkFlagRequired("name")
	updateCmd.MarkFlagRequired("version")
}
// core/cache.go
package core

import (
	"crypto/sha256"
	"fmt"
	"io"
	"os"
	"path/filepath"
)

// CacheDependency caches the downloaded package data.
func CacheDependency(dep Dependency, data io.Reader) error {
	cacheDir := "pkgmgr_cache"
	if _, err := os.Stat(cacheDir); os.IsNotExist(err) {
		if err := os.Mkdir(cacheDir, 0755); err != nil {
			return err
		}
	}

	hash := sha256.New()
	tee := io.TeeReader(data, hash)

	// Read the data to compute hash
	_, err := io.Copy(io.Discard, tee)
	if err != nil {
		return err
	}
	checksum := fmt.Sprintf("%x", hash.Sum(nil))

	// Create cache file path
	cachePath := filepath.Join(cacheDir, fmt.Sprintf("%s-%s.cache", dep.Name, checksum))
	if _, err := os.Stat(cachePath); err == nil {
		// Cached version exists
		return nil
	}

	// Save to cache
	file, err := os.Create(cachePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Reset the reader if possible or handle accordingly
	// This depends on how data is passed. If data is already consumed, consider reading from the original source again.

	return nil
}
// core/command.go
package core

import (
	"os/exec"
)

// Command represents an external command to be executed.
type Command struct {
	Name string
	Args []string
	// Optionally, you can add fields like Env, Dir, etc.
}

// Executor defines methods to execute commands.
type Executor interface {
	Run(cmd *Command) error
	Output(cmd *Command) ([]byte, error)
}

// RealExecutor is the default implementation of Executor using exec.Command.
type RealExecutor struct{}

func (e *RealExecutor) Run(cmd *Command) error {
	command := exec.Command(cmd.Name, cmd.Args...)
	command.Stdout = nil
	command.Stderr = nil
	return command.Run()
}

func (e *RealExecutor) Output(cmd *Command) ([]byte, error) {
	command := exec.Command(cmd.Name, cmd.Args...)
	return command.Output()
}
// core/config.go
package core

import (
	"fmt"

	"github.com/go-playground/validator/v10"
)

// Config represents the entire project configuration.
type Config struct {
	Project        ProjectConfig                `yaml:"project" validate:"required,dive"`
	Environments   map[string]EnvironmentConfig `yaml:"environments" validate:"required,dive"`
	TrustedSources map[string][]string          `yaml:"trusted_sources" validate:"required,dive,dive,uri"`
}

// EnvironmentConfig holds dependencies for a specific environment.
type EnvironmentConfig struct {
	Dependencies map[string][]Dependency `yaml:"dependencies" validate:"required,dive,dive"`
}

// ProjectConfig holds project metadata.
type ProjectConfig struct {
	Name        string   `yaml:"name" validate:"required"`
	Version     string   `yaml:"version" validate:"required,semver"`
	Description string   `yaml:"description"`
	Authors     []Author `yaml:"authors" validate:"dive"`
}

// Author represents a project author.
type Author struct {
	Name  string `yaml:"name" validate:"required"`
	Email string `yaml:"email" validate:"required,email"`
}

// Validate parses and validates the entire configuration.
func (c *Config) Validate() error {
	validate := validator.New()
	// Register custom validation
	validate.RegisterValidation("semver", validateSemVer)

	// Validate Project
	if err := validate.Struct(c.Project); err != nil {
		return err
	}

	// Validate Environments
	for envName, envConfig := range c.Environments {
		if err := validate.Struct(envConfig); err != nil {
			return fmt.Errorf("validation failed for environment '%s': %v", envName, err)
		}
		for lang, deps := range envConfig.Dependencies {
			for _, dep := range deps {
				if err := dep.Validate(); err != nil {
					return fmt.Errorf("invalid dependency '%s' in environment '%s', language '%s': %v", dep.Name, envName, lang, err)
				}
			}
		}
	}

	return nil
}
// core/constants.go
package core

const (
	PluginAPIVersion = "1.0.0"
	MaxConcurrency   = 5 // Adjust as needed
)
// core/dependency.go
package core

import (
	"fmt"

	"github.com/Masterminds/semver/v3"
	"github.com/go-playground/validator/v10"
)

// Dependency represents a package dependency.
type Dependency struct {
	Name       string              `yaml:"name" validate:"required"`
	Version    string              `yaml:"version" validate:"required"`
	Constraint *semver.Constraints `yaml:"-"`
}

// Validate parses and validates the dependency.
func (d *Dependency) Validate() error {
	validate := validator.New()
	// Register custom validation for semantic versioning
	validate.RegisterValidation("semver", validateSemVer)

	err := validate.Struct(d)
	if err != nil {
		return err
	}

	// Parse semantic version constraint
	constraint, err := semver.NewConstraint(d.Version)
	if err != nil {
		return fmt.Errorf("invalid version constraint '%s': %v", d.Version, err)
	}
	d.Constraint = constraint

	return nil
}

// validateSemVer ensures the version string adheres to semantic versioning.
func validateSemVer(fl validator.FieldLevel) bool {
	_, err := semver.NewConstraint(fl.Field().String())
	return err == nil
}
// core/init_plugins.go
package core

import (
	"log"

	// Import your plugin packages here
	"github.com/GH-Solutions-Consultants/Paxly/plugins/go"
	"github.com/GH-Solutions-Consultants/Paxly/plugins/python"
)

func init() {
	registry := GetPluginRegistry()

	// Register Go plugin
	goPlugin, err := plugins_go.NewGoPlugin()
	if err != nil {
		log.Fatalf("Failed to initialize Go plugin: %v", err)
	}
	registry.RegisterPlugin("go", goPlugin)

	// Register Python plugin
	pythonPlugin, err := plugins_python.NewPythonPlugin()
	if err != nil {
		log.Fatalf("Failed to initialize Python plugin: %v", err)
	}
	registry.RegisterPlugin("python", pythonPlugin)

	// Register other plugins similarly
}
// core/logger.go
package core

import (
	"os"

	"github.com/sirupsen/logrus"
)

// InitializeLogger sets up the global logger.
func InitializeLogger() {
	logrus.SetFormatter(&logrus.TextFormatter{
		FullTimestamp: true,
	})
	logrus.SetOutput(os.Stdout)
	logrus.SetLevel(logrus.WarnLevel) // Default level
}

// LogFatal logs the error and exits the application.
func LogFatal(err error) {
	logrus.Fatal(err)
}
// core/plugin.go
package core

import (
	"fmt"
	"sync"
)

// PackageManagerPlugin defines the interface that all language-specific plugins must implement.
type PackageManagerPlugin interface {
	APIVersion() string
	Language() string
	Initialize(config Config) error
	Install(deps []Dependency) error
	Update(deps []Dependency) error
	Remove(dep Dependency) error
	List() ([]Dependency, error)
	ListVersions(depName string) ([]string, error)
	GetTransitiveDependencies(depName, version string) ([]Dependency, error)
	GetVulnerabilities() ([]SecurityVulnerability, error) // Newly added method
	Cleanup() error
}

// PluginRegistry manages all registered plugins.
type PluginRegistry struct {
	plugins map[string]PackageManagerPlugin
	mu      sync.RWMutex
}

// NewPluginRegistry creates a new PluginRegistry instance.
func NewPluginRegistry() *PluginRegistry {
	return &PluginRegistry{
		plugins: make(map[string]PackageManagerPlugin),
	}
}

// RegisterPlugin registers a new plugin.
func (pr *PluginRegistry) RegisterPlugin(plugin PackageManagerPlugin) error {
	pr.mu.Lock()
	defer pr.mu.Unlock()

	if plugin.APIVersion() != PluginAPIVersion {
		return fmt.Errorf("plugin %s has incompatible API version: got %s, expected %s",
			plugin.Language(), plugin.APIVersion(), PluginAPIVersion)
	}

	lang := plugin.Language()
	if _, exists := pr.plugins[lang]; exists {
		return fmt.Errorf("plugin for language '%s' is already registered", lang)
	}

	pr.plugins[lang] = plugin
	return nil
}

// GetPlugin retrieves a plugin by language.
func (pr *PluginRegistry) GetPlugin(lang string) (PackageManagerPlugin, bool) {
	pr.mu.RLock()
	defer pr.mu.RUnlock()

	plugin, exists := pr.plugins[lang]
	return plugin, exists
}

// GetAllPlugins retrieves all registered plugins.
func (pr *PluginRegistry) GetAllPlugins() map[string]PackageManagerPlugin {
	pr.mu.RLock()
	defer pr.mu.RUnlock()

	// Return a copy to prevent external modification
	pluginsCopy := make(map[string]PackageManagerPlugin)
	for lang, plugin := range pr.plugins {
		pluginsCopy[lang] = plugin
	}
	return pluginsCopy
}
// core/plugin_registry.go
package core

import (
    "sync"
)

// Plugin represents a generic plugin interface.
type Plugin interface {
    Install(dependencies []Dependency) error
    List() ([]Dependency, error)
    // Add other necessary methods
}

// Dependency represents a single dependency with a name and version.
type Dependency struct {
    Name    string
    Version string
}

// PluginRegistry manages all available plugins.
type PluginRegistry struct {
    plugins map[string]Plugin
    mu      sync.RWMutex
}

// NewPluginRegistry creates a new instance of PluginRegistry.
func NewPluginRegistry() *PluginRegistry {
    return &PluginRegistry{
        plugins: make(map[string]Plugin),
    }
}

// RegisterPlugin registers a new plugin for a given language.
func (pr *PluginRegistry) RegisterPlugin(language string, plugin Plugin) {
    pr.mu.Lock()
    defer pr.mu.Unlock()
    pr.plugins[language] = plugin
}

// GetPlugin retrieves a plugin by language.
func (pr *PluginRegistry) GetPlugin(language string) (Plugin, bool) {
    pr.mu.RLock()
    defer pr.mu.RUnlock()
    plugin, exists := pr.plugins[language]
    return plugin, exists
}

// Singleton pattern for PluginRegistry
var (
    pluginRegistryInstance *PluginRegistry
    once                   sync.Once
)

// GetPluginRegistry returns the singleton instance of PluginRegistry.
func GetPluginRegistry() *PluginRegistry {
    once.Do(func() {
        pluginRegistryInstance = NewPluginRegistry()
    })
    return pluginRegistryInstance
}
// core/plugin_registry_singleton.go
package core

import "sync"

var (
	pluginRegistryInstance *PluginRegistry
	once                   sync.Once
)

// GetPluginRegistry returns the singleton instance of PluginRegistry.
func GetPluginRegistry() *PluginRegistry {
	once.Do(func() {
		pluginRegistryInstance = NewPluginRegistry()
		// Register default plugins here if necessary
	})
	return pluginRegistryInstance
}
// core/project.go
package core

import (
	"fmt"
	"os"
	"regexp"

	"gopkg.in/yaml.v2"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

// InitializeProject initializes a new pkgmgr project by creating a pkgmgr.yaml file.
func InitializeProject(name, version, description string, authors []string) error {
	if name == "" {
		return fmt.Errorf("project name is required")
	}

	authorStructs := []Author{}
	for _, authorStr := range authors {
		author, err := parseAuthor(authorStr)
		if err != nil {
			return errors.Wrapf(err, "invalid author format '%s'", authorStr)
		}
		authorStructs = append(authorStructs, author)
	}

	config := Config{
		Project: ProjectConfig{
			Name:        name,
			Version:     version,
			Description: description,
			Authors:     authorStructs,
		},
		Environments: map[string]EnvironmentConfig{
			"development": {
				Dependencies: map[string][]Dependency{},
			},
			"production": {
				Dependencies: map[string][]Dependency{},
			},
		},
		TrustedSources: map[string][]string{
			"python":      {"https://pypi.org/simple"},
			"javascript":  {"https://registry.npmjs.org/"},
			"go":          {"https://proxy.golang.org/"},
			"rust":        {"https://crates.io/"},
		},
	}

	data, err := yaml.Marshal(&config)
	if err != nil {
		return errors.Wrap(err, "failed to marshal configuration")
	}

	if _, err := os.Stat("pkgmgr.yaml"); err == nil {
		return fmt.Errorf("pkgmgr.yaml already exists")
	}

	err = os.WriteFile("pkgmgr.yaml", data, 0644)
	if err != nil {
		return errors.Wrap(err, "failed to write pkgmgr.yaml")
	}

	logrus.Info("Initialized pkgmgr project with pkgmgr.yaml")

	// Validate the config
	if err := config.Validate(); err != nil {
		return errors.Wrap(err, "configuration validation failed")
	}

	logrus.Info("Configuration validated successfully.")

	return nil
}

// parseAuthor parses a string in the format "Name <email>"
func parseAuthor(authorStr string) (Author, error) {
	re := regexp.MustCompile(`^(.*?)\s*<(.+)>$`)
	matches := re.FindStringSubmatch(authorStr)
	if len(matches) != 3 {
		return Author{}, fmt.Errorf("invalid author format")
	}
	return Author{
		Name:  matches[1],
		Email: matches[2],
	}, nil
}
// core/resolver.go
package core

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"sort"

	"github.com/Masterminds/semver/v3"
	"github.com/sirupsen/logrus"
)

// Resolver handles dependency resolution.
type Resolver struct {
	Config         Config
	PluginRegistry *PluginRegistry
	resolvedDeps   map[string]*semver.Version
	processingDeps map[string]bool // To detect cycles
}

// NewResolver creates a new Resolver instance.
func NewResolver(config Config, pr *PluginRegistry) *Resolver {
	return &Resolver{
		Config:         config,
		PluginRegistry: pr,
		resolvedDeps:   make(map[string]*semver.Version),
		processingDeps: make(map[string]bool),
	}
}

// ResolveDependencies resolves all dependencies recursively for a given environment.
func (r *Resolver) ResolveDependencies(env string) error {
	envConfig, exists := r.Config.Environments[env]
	if !exists {
		return fmt.Errorf("environment '%s' not found in configuration", env)
	}

	for lang, deps := range envConfig.Dependencies {
		for _, dep := range deps {
			if err := r.resolveDependency(lang, dep); err != nil {
				return err
			}
		}
	}

	return nil
}

// resolveDependency resolves a single dependency and its transitive dependencies.
func (r *Resolver) resolveDependency(lang string, dep Dependency) error {
	if err := dep.Validate(); err != nil {
		return fmt.Errorf("invalid dependency '%s' in language '%s': %v", dep.Name, lang, err)
	}

	// Check for cycles.
	if r.processingDeps[dep.Name] {
		return fmt.Errorf("cyclic dependency detected on '%s'", dep.Name)
	}

	// If already resolved, verify version compatibility.
	if existingVersion, exists := r.resolvedDeps[dep.Name]; exists {
		if !dep.Constraint.Check(existingVersion) {
			return fmt.Errorf("version conflict for '%s': existing version '%s' does not satisfy constraint '%s'", dep.Name, existingVersion, dep.Version)
		}
		return nil // Already resolved and compatible.
	}

	// Mark as processing.
	r.processingDeps[dep.Name] = true
	defer delete(r.processingDeps, dep.Name)

	// Fetch the latest compatible version.
	version, err := r.getLatestCompatibleVersion(lang, dep)
	if err != nil {
		return err
	}
	r.resolvedDeps[dep.Name] = version

	// Fetch transitive dependencies.
	transDeps, err := r.getTransitiveDependencies(lang, dep.Name, version)
	if err != nil {
		return err
	}

	// Recursively resolve transitive dependencies.
	for _, tDep := range transDeps {
		if err := r.resolveDependency(lang, tDep); err != nil {
			return err
		}
	}

	return nil
}

// getLatestCompatibleVersion retrieves the latest compatible version of a dependency.
func (r *Resolver) getLatestCompatibleVersion(lang string, dep Dependency) (*semver.Version, error) {
	plugin, exists := r.PluginRegistry.GetPlugin(lang)
	if !exists {
		return nil, fmt.Errorf("no plugin found for language '%s'", lang)
	}

	availableVersions, err := plugin.ListVersions(dep.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to list available versions for '%s': %v", dep.Name, err)
	}

	var compatibleVersions []*semver.Version
	for _, vStr := range availableVersions {
		v, err := semver.NewVersion(vStr)
		if err != nil {
			continue
		}
		if dep.Constraint.Check(v) {
			compatibleVersions = append(compatibleVersions, v)
		}
	}

	if len(compatibleVersions) == 0 {
		return nil, fmt.Errorf("no compatible versions found for '%s' with constraint '%s'", dep.Name, dep.Version)
	}

	// Sort the versions in ascending order and select the latest.
	sort.Slice(compatibleVersions, func(i, j int) bool {
		return compatibleVersions[i].LessThan(compatibleVersions[j])
	})
	latestVersion := compatibleVersions[len(compatibleVersions)-1]
	return latestVersion, nil
}

// getTransitiveDependencies fetches transitive dependencies for a given dependency.
func (r *Resolver) getTransitiveDependencies(lang, depName string, version *semver.Version) ([]Dependency, error) {
	plugin, exists := r.PluginRegistry.GetPlugin(lang)
	if !exists {
		return nil, fmt.Errorf("no plugin found for language '%s'", lang)
	}

	transDeps, err := plugin.GetTransitiveDependencies(depName, version.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get transitive dependencies for '%s@%s': %v", depName, version, err)
	}

	return transDeps, nil
}

// SecurityReport represents a security report for a language.
type SecurityReport struct {
	Language        string                 `json:"language"`
	Vulnerabilities []SecurityVulnerability `json:"vulnerabilities"`
}

// CollectSecurityReports collects security vulnerabilities from each plugin and generates reports.
func (r *Resolver) CollectSecurityReports() error {
	var securityReports []SecurityReport

	plugins := r.PluginRegistry.GetAllPlugins()
	for lang, plugin := range plugins {
		// Each plugin should expose a method to retrieve vulnerabilities
		vulns, err := plugin.GetVulnerabilities()
		if err != nil {
			logrus.Errorf("Failed to get vulnerabilities for '%s': %v", lang, err)
			continue
		}

		securityReports = append(securityReports, SecurityReport{
			Language:        lang,
			Vulnerabilities: vulns,
		})
	}

	// Generate security report in JSON
	if err := GenerateSecurityReport(securityReports, "json", "security_report.json"); err != nil {
		logrus.Errorf("Failed to generate JSON security report: %v", err)
		return err
	}

	// Generate security report in HTML
	if err := GenerateSecurityReport(securityReports, "html", "security_report.html"); err != nil {
		logrus.Errorf("Failed to generate HTML security report: %v", err)
		return err
	}

	return nil
}

// GenerateSecurityReport generates a security report in the specified format.
func GenerateSecurityReport(reports []SecurityReport, format, outputPath string) error {
	var data []byte
	var err error

	switch format {
	case "json":
		data, err = json.MarshalIndent(reports, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal security report to JSON: %v", err)
		}
	case "html":
		// Simple HTML template
		var buffer bytes.Buffer
		buffer.WriteString("<html><head><title>Security Report</title></head><body><h1>Security Report</h1>")
		for _, report := range reports {
			buffer.WriteString(fmt.Sprintf("<h2>%s</h2>", report.Language))
			if len(report.Vulnerabilities) == 0 {
				buffer.WriteString("<p>No vulnerabilities found.</p>")
				continue
			}
			buffer.WriteString("<ul>")
			for _, vuln := range report.Vulnerabilities {
				buffer.WriteString(fmt.Sprintf("<li><strong>%s:</strong> %s (Severity: %s)</li>", vuln.Package, vuln.Vulnerability, vuln.Severity))
			}
			buffer.WriteString("</ul>")
		}
		buffer.WriteString("</body></html>")
		data = buffer.Bytes()
	default:
		return fmt.Errorf("unsupported report format '%s'", format)
	}

	// Write to file
	if err := os.WriteFile(outputPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write security report to '%s': %v", outputPath, err)
	}

	logrus.Infof("Security report generated at '%s'", outputPath)
	return nil
}
// core/security.go
package core

// SecurityVulnerability represents a security issue found in a dependency.
type SecurityVulnerability struct {
	Package       string `json:"package"`
	Vulnerability string `json:"vulnerability"`
	Severity      string `json:"severity,omitempty"`
	Description   string `json:"description,omitempty"`
}
// core/utils.go
package core

import "runtime"

// IsWindows checks if the current OS is Windows.
func IsWindows() bool {
	return runtime.GOOS == "windows"
}
// plugins/go/go_plugin.go
package go_plugin

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/sirupsen/logrus"
)

// Ensure the GoPlugin implements the PackageManagerPlugin interface.
var _ core.PackageManagerPlugin = (*GoPlugin)(nil)

// GoPlugin is the plugin for managing Go dependencies.
type GoPlugin struct {
	executor core.Executor
}

// NewGoPlugin creates a new instance of GoPlugin with the given executor.
func NewGoPlugin(executor core.Executor) *GoPlugin {
	if executor == nil {
		executor = &core.RealExecutor{}
	}
	return &GoPlugin{
		executor: executor,
	}
}

// APIVersion returns the plugin API version.
func (p *GoPlugin) APIVersion() string {
	return core.PluginAPIVersion
}

// Language returns the name of the language this plugin manages.
func (p *GoPlugin) Language() string {
	return "go"
}

// Initialize sets up the Go plugin with necessary configurations.
func (p *GoPlugin) Initialize(config core.Config) error {
	logrus.Info("Initializing Go plugin...")
	// Validate Go installation
	if _, err := exec.LookPath("go"); err != nil {
		return fmt.Errorf("go is not installed or not in PATH")
	}
	// Ensure go.mod exists; if not, initialize it
	if _, err := os.Stat("go.mod"); os.IsNotExist(err) {
		logrus.Info("go.mod not found. Initializing Go module...")
		cmd := exec.Command("go", "mod", "init", config.Project.Name)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to initialize Go module: %v", err)
		}
	}
	return nil
}

// Install installs the specified Go dependencies.
func (p *GoPlugin) Install(deps []core.Dependency) error {
	for _, dep := range deps {
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Installing Go package")

		cmd := core.Command{
			Name: "go",
			Args: []string{"get", dep.Name},
		}
		err := p.executor.Run(&cmd)
		if err != nil {
			logrus.Errorf("Failed to install Go package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully installed Go package: %s", dep.Name)
	}

	// Run go mod tidy to clean up dependencies
	if err := p.runGoModTidy(); err != nil {
		logrus.Errorf("Failed to run 'go mod tidy': %v", err)
		return err
	}

	// Optionally, run security scans here if integrated

	return nil
}

// Update updates the specified Go dependencies.
func (p *GoPlugin) Update(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s@%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Updating Go package")

		cmd := core.Command{
			Name: "go",
			Args: []string{"get", "-u", pkgStr},
		}
		err := p.executor.Run(&cmd)
		if err != nil {
			logrus.Errorf("Failed to update Go package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully updated Go package: %s", dep.Name)
	}

	// Run go mod tidy to clean up dependencies
	if err := p.runGoModTidy(); err != nil {
		logrus.Errorf("Failed to run 'go mod tidy': %v", err)
		return err
	}

	return nil
}

// Remove removes the specified Go dependency.
func (p *GoPlugin) Remove(dep core.Dependency) error {
	pkgStr := dep.Name
	logrus.WithFields(logrus.Fields{
		"dependency": dep.Name,
	}).Info("Removing Go package")

	// To remove a dependency, we need to edit go.mod to remove the require directive
	// Since Go doesn't have a direct command to remove a module, we'll use 'go mod tidy' after manual removal

	// Remove the dependency from go.mod by running 'go mod edit -droprequire=dep.Name'
	cmd := core.Command{
		Name: "go",
		Args: []string{"mod", "edit", "-droprequire", dep.Name},
	}
	err := p.executor.Run(&cmd)
	if err != nil {
		logrus.Errorf("Failed to remove Go package '%s' from go.mod: %v", dep.Name, err)
		return err
	}

	// Run go mod tidy to clean up
	if err := p.runGoModTidy(); err != nil {
		logrus.Errorf("Failed to run 'go mod tidy' after removing package '%s': %v", dep.Name, err)
		return err
	}

	logrus.Infof("Successfully removed Go package: %s", dep.Name)
	return nil
}

// List lists all installed Go dependencies.
func (p *GoPlugin) List() ([]core.Dependency, error) {
	cmd := core.Command{
		Name: "go",
		Args: []string{"list", "-m", "all"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list Go modules: %v", err)
	}

	lines := strings.Split(string(output), "\n")
	deps := []core.Dependency{}
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Fields(line)
		if len(parts) < 2 {
			continue
		}
		deps = append(deps, core.Dependency{
			Name:    parts[0],
			Version: "=" + parts[1],
		})
	}

	return deps, nil
}

// ListVersions lists all available versions for a given Go dependency.
func (p *GoPlugin) ListVersions(depName string) ([]string, error) {
	cmd := core.Command{
		Name: "go",
		Args: []string{"list", "-m", "-versions", depName},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list versions for '%s': %v", depName, err)
	}

	parts := strings.Fields(string(output))
	if len(parts) < 2 {
		return nil, fmt.Errorf("no versions found for '%s'", depName)
	}

	versions := strings.Split(parts[1], " ")
	return versions, nil
}

// GetTransitiveDependencies fetches transitive dependencies for a given dependency.
func (p *GoPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	// Use 'go list -m -json all' to parse dependencies
	cmd := core.Command{
		Name: "go",
		Args: []string{"list", "-m", "-json", "all"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list modules for '%s': %v", depName, err)
	}

	var modules []map[string]interface{}
	dec := json.NewDecoder(bytes.NewReader(output))
	for {
		var m map[string]interface{}
		if err := dec.Decode(&m); err != nil {
			break
		}
		modules = append(modules, m)
	}

	transDeps := []core.Dependency{}
	for _, mod := range modules {
		if mod["Path"] == depName && mod["Version"] == version {
			if deps, ok := mod["Dependencies"].([]interface{}); ok {
				for _, d := range deps {
					if depMap, ok := d.(string); ok {
						parts := strings.Split(depMap, " ")
						if len(parts) >= 2 {
							transDeps = append(transDeps, core.Dependency{
								Name:    parts[0],
								Version: "=" + parts[1],
							})
						} else {
							transDeps = append(transDeps, core.Dependency{
								Name:    parts[0],
								Version: "",
							})
						}
					}
				}
			}
			break
		}
	}

	return transDeps, nil
}

// GetVulnerabilities retrieves security vulnerabilities using 'go list -m -json all' and an external tool.
func (p *GoPlugin) GetVulnerabilities() ([]core.SecurityVulnerability, error) {
	// Placeholder: Implement integration with a security tool like 'go-critic' or 'govulncheck'
	// For demonstration, we'll return an empty slice
	return []core.SecurityVulnerability{}, nil
}

// Cleanup performs any necessary cleanup operations.
func (p *GoPlugin) Cleanup() error {
	logrus.Info("Cleaning up Go plugin resources...")
	// Implement any necessary cleanup
	return nil
}

// runGoModTidy runs 'go mod tidy' to clean up dependencies.
func (p *GoPlugin) runGoModTidy() error {
	cmd := core.Command{
		Name: "go",
		Args: []string{"mod", "tidy"},
	}
	err := p.executor.Run(&cmd)
	if err != nil {
		return fmt.Errorf("failed to run 'go mod tidy': %v", err)
	}
	logrus.Info("Successfully ran 'go mod tidy'")
	return nil
}
// plugins/javascript/javascript_plugin.go
package javascript

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"

	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/sirupsen/logrus"
)

// Ensure the JavaScriptPlugin implements the PackageManagerPlugin interface.
var _ core.PackageManagerPlugin = (*JavaScriptPlugin)(nil)

// JavaScriptPlugin is the plugin for managing JavaScript dependencies.
type JavaScriptPlugin struct {
	executor core.Executor
}

// NewJavaScriptPlugin creates a new instance of JavaScriptPlugin with the given executor.
func NewJavaScriptPlugin(executor core.Executor) *JavaScriptPlugin {
	if executor == nil {
		executor = &core.RealExecutor{}
	}
	return &JavaScriptPlugin{
		executor: executor,
	}
}

// APIVersion returns the plugin API version.
func (p *JavaScriptPlugin) APIVersion() string {
	return core.PluginAPIVersion
}

// Language returns the name of the language this plugin manages.
func (p *JavaScriptPlugin) Language() string {
	return "javascript"
}

// Initialize sets up the JavaScript plugin with necessary configurations.
func (p *JavaScriptPlugin) Initialize(config core.Config) error {
	logrus.Info("Initializing JavaScript plugin...")
	// Validate npm installation
	if _, err := exec.LookPath("npm"); err != nil {
		return fmt.Errorf("npm is not installed or not in PATH")
	}
	// Ensure package.json exists; if not, initialize it
	if _, err := os.Stat("package.json"); os.IsNotExist(err) {
		logrus.Info("package.json not found. Initializing npm project...")
		cmd := exec.Command("npm", "init", "-y")
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to initialize npm project: %v", err)
		}
	}
	return nil
}

// Install installs the specified JavaScript dependencies.
func (p *JavaScriptPlugin) Install(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s@%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Installing JavaScript package")

		cmd := core.Command{
			Name: "npm",
			Args: []string{"install", pkgStr},
		}
		err := p.executor.Run(&cmd)
		if err != nil {
			logrus.Errorf("Failed to install JavaScript package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully installed JavaScript package: %s", dep.Name)
	}

	// Optionally, run 'npm audit' here if integrated

	return nil
}

// Update updates the specified JavaScript dependencies.
func (p *JavaScriptPlugin) Update(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s@%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Updating JavaScript package")

		cmd := core.Command{
			Name: "npm",
			Args: []string{"install", pkgStr},
		}
		err := p.executor.Run(&cmd)
		if err != nil {
			logrus.Errorf("Failed to update JavaScript package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully updated JavaScript package: %s", dep.Name)
	}

	return nil
}

// Remove removes the specified JavaScript dependency.
func (p *JavaScriptPlugin) Remove(dep core.Dependency) error {
	pkgStr := dep.Name
	logrus.WithFields(logrus.Fields{
		"dependency": dep.Name,
	}).Info("Removing JavaScript package")

	cmd := core.Command{
		Name: "npm",
		Args: []string{"uninstall", pkgStr},
	}
	err := p.executor.Run(&cmd)
	if err != nil {
		logrus.Errorf("Failed to remove JavaScript package '%s': %v", dep.Name, err)
		return err
	}

	logrus.Infof("Successfully removed JavaScript package: %s", dep.Name)
	return nil
}

// List lists all installed JavaScript dependencies.
func (p *JavaScriptPlugin) List() ([]core.Dependency, error) {
	cmd := core.Command{
		Name: "npm",
		Args: []string{"list", "--json", "--depth=0"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list JavaScript packages: %v", err)
	}

	var listOutput struct {
		Dependencies map[string]interface{} `json:"dependencies"`
	}

	if err := json.Unmarshal(output, &listOutput); err != nil {
		return nil, fmt.Errorf("failed to parse npm list output: %v", err)
	}

	deps := []core.Dependency{}
	for name, info := range listOutput.Dependencies {
		version, ok := info.(map[string]interface{})["version"].(string)
		if !ok {
			continue
		}
		deps = append(deps, core.Dependency{
			Name:    name,
			Version: "=" + version,
		})
	}

	return deps, nil
}

// ListVersions lists all available versions for a given JavaScript dependency.
func (p *JavaScriptPlugin) ListVersions(depName string) ([]string, error) {
	cmd := core.Command{
		Name: "npm",
		Args: []string{"view", depName, "versions", "--json"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list versions for '%s': %v", depName, err)
	}

	var versions []string
	if err := json.Unmarshal(output, &versions); err != nil {
		return nil, fmt.Errorf("failed to parse npm versions: %v", err)
	}

	return versions, nil
}

// GetTransitiveDependencies fetches transitive dependencies for a given dependency.
func (p *JavaScriptPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	// Use 'npm ls <depName> --json' to get dependencies
	cmd := core.Command{
		Name: "npm",
		Args: []string{"ls", depName, "--json"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to list dependencies for '%s': %v", depName, err)
	}

	var lsOutput struct {
		Dependencies map[string]struct {
			Version       string                 `json:"version"`
			Dependencies  map[string]interface{} `json:"dependencies"`
			DevDependencies map[string]interface{} `json:"devDependencies"`
		} `json:"dependencies"`
	}

	if err := json.Unmarshal(output, &lsOutput); err != nil {
		return nil, fmt.Errorf("failed to parse npm ls output: %v", err)
	}

	transDeps := []core.Dependency{}
	if deps, ok := lsOutput.Dependencies[depName].Dependencies; ok {
		for name, info := range deps {
			version, ok := info.(map[string]interface{})["version"].(string)
			if !ok {
				continue
			}
			transDeps = append(transDeps, core.Dependency{
				Name:    name,
				Version: "=" + version,
			})
		}
	}

	return transDeps, nil
}

// GetVulnerabilities retrieves security vulnerabilities using 'npm audit --json'.
func (p *JavaScriptPlugin) GetVulnerabilities() ([]core.SecurityVulnerability, error) {
	cmd := core.Command{
		Name: "npm",
		Args: []string{"audit", "--json"},
	}
	output, err := p.executor.Output(&cmd)
	if err != nil {
		// npm audit returns non-zero exit code if vulnerabilities are found
		// We still need to parse the output
		if exitErr, ok := err.(*exec.ExitError); ok {
			output = exitErr.Stderr
		} else {
			return nil, fmt.Errorf("failed to run npm audit: %v", err)
		}
	}

	var auditOutput struct {
		Vulnerabilities map[string]struct {
			Title       string `json:"title"`
			ModuleName  string `json:"module_name"`
			Severity    string `json:"severity"`
			Overview    string `json:"overview"`
			PatchedBy   []string `json:"patched_by"`
			Recommendation string `json:"recommendation"`
		} `json:"vulnerabilities"`
	}

	if err := json.Unmarshal(output, &auditOutput); err != nil {
		return nil, fmt.Errorf("failed to parse npm audit output: %v", err)
	}

	vulns := []core.SecurityVulnerability{}
	for _, vuln := range auditOutput.Vulnerabilities {
		vulns = append(vulns, core.SecurityVulnerability{
			Package:       vuln.ModuleName,
			Vulnerability: vuln.Title,
			Severity:      vuln.Severity,
			Description:   vuln.Overview,
		})
	}

	return vulns, nil
}

// Cleanup performs any necessary cleanup operations.
func (p *JavaScriptPlugin) Cleanup() error {
	logrus.Info("Cleaning up JavaScript plugin resources...")
	// Implement any necessary cleanup
	return nil
}
// plugins/python/python_plugin.go
package python

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"bytes"

	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/sirupsen/logrus"
)

// Ensure the PythonPlugin implements the PackageManagerPlugin interface.
var _ core.PackageManagerPlugin = (*PythonPlugin)(nil)

// PythonPlugin is the plugin for managing Python dependencies.
type PythonPlugin struct {
	executor core.Executor
}

// NewPythonPlugin creates a new instance of PythonPlugin with the given executor.
func NewPythonPlugin(executor core.Executor) *PythonPlugin {
	if executor == nil {
		executor = &core.RealExecutor{}
	}
	return &PythonPlugin{
		executor: executor,
	}
}

// APIVersion returns the plugin API version.
func (p *PythonPlugin) APIVersion() string {
	return core.PluginAPIVersion
}

// Language returns the name of the language this plugin manages.
func (p *PythonPlugin) Language() string {
	return "python"
}

// Initialize sets up the Python plugin with necessary configurations.
func (p *PythonPlugin) Initialize(config core.Config) error {
	logrus.Info("Initializing Python plugin...")
	// Validate Python installation
	if _, err := p.executor.Run(&core.Command{Name: "python3", Args: []string{"--version"}}); err != nil {
		return fmt.Errorf("python3 is not installed or not in PATH")
	}
	if _, err := p.executor.Run(&core.Command{Name: p.getPipPath(), Args: []string{"--version"}}); err != nil {
		return fmt.Errorf("pip is not installed or not in PATH")
	}
	// Ensure pipdeptree is installed
	if err := p.ensurePipDeptree(); err != nil {
		return err
	}
	return nil
}

// ensurePipDeptree ensures that pipdeptree is installed in the virtual environment.
func (p *PythonPlugin) ensurePipDeptree() error {
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"install", "pipdeptree"},
	}
	if err := p.executor.Run(cmd); err != nil {
		return fmt.Errorf("failed to install pipdeptree: %v", err)
	}
	return nil
}

// getPipPath returns the path to the pip executable, handling cross-platform paths.
func (p *PythonPlugin) getPipPath() string {
	if core.IsWindows() {
		return filepath.Join("venv", "Scripts", "pip.exe")
	}
	return filepath.Join("venv", "bin", "pip")
}

// Install installs the specified Python dependencies along with transitive dependencies.
func (p *PythonPlugin) Install(deps []core.Dependency) error {
	// Check if virtual environment exists.
	_, err := os.Stat("venv")
	if os.IsNotExist(err) {
		logrus.Info("Creating Python virtual environment...")
		cmd := &core.Command{
			Name: "python3",
			Args: []string{"-m", "venv", "venv"},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to create virtual environment: %v", err)
			return err
		}
	} else if err != nil {
		return fmt.Errorf("error checking virtual environment: %v", err)
	}

	// Install dependencies
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Installing Python package")

		cmd := &core.Command{
			Name: p.getPipPath(),
			Args: []string{"install", pkgStr},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to install Python package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully installed Python package: %s", dep.Name)

		// Resolve transitive dependencies.
		transDeps, err := p.GetTransitiveDependencies(dep.Name, dep.Constraint.String())
		if err != nil {
			logrus.Warnf("Failed to get transitive dependencies for '%s': %v", dep.Name, err)
			continue
		}
		if len(transDeps) > 0 {
			logrus.Infof("Resolving transitive dependencies for '%s'", dep.Name)
			if err := p.Install(transDeps); err != nil {
				logrus.Errorf("Failed to install transitive dependencies for '%s': %v", dep.Name, err)
			}
		}
	}

	// Run security scans after installation.
	if err := p.RunSecurityScan(); err != nil {
		logrus.Warnf("Security scan encountered issues: %v", err)
	}

	return nil
}

// Update updates the specified Python dependencies.
func (p *PythonPlugin) Update(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Updating Python package")

		cmd := &core.Command{
			Name: p.getPipPath(),
			Args: []string{"install", "--upgrade", pkgStr},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to update Python package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully updated Python package: %s", dep.Name)
	}

	// Run security scans after update.
	if err := p.RunSecurityScan(); err != nil {
		logrus.Warnf("Security scan encountered issues: %v", err)
	}

	return nil
}

// Remove removes the specified Python dependency.
func (p *PythonPlugin) Remove(dep core.Dependency) error {
	pkgStr := dep.Name
	logrus.WithFields(logrus.Fields{
		"dependency": dep.Name,
	}).Info("Removing Python package")

	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"uninstall", "-y", pkgStr},
	}
	if err := p.executor.Run(cmd); err != nil {
		logrus.Errorf("Failed to remove Python package '%s': %v", dep.Name, err)
		return err
	}
	logrus.Infof("Successfully removed Python package: %s", dep.Name)

	return nil
}

// List lists all installed Python dependencies.
func (p *PythonPlugin) List() ([]core.Dependency, error) {
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"freeze"},
	}
	output, err := p.executor.Output(cmd)
	if err != nil {
		return nil, err
	}

	deps := []core.Dependency{}
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Split(line, "==")
		if len(parts) != 2 {
			continue
		}
		deps = append(deps, core.Dependency{
			Name:    parts[0],
			Version: "=" + parts[1],
		})
	}

	return deps, nil
}

// ListVersions lists all available versions for a given Python package.
func (p *PythonPlugin) ListVersions(depName string) ([]string, error) {
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"install", fmt.Sprintf("%s==random", depName)}, // Intentional error to get available versions
	}
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	err := p.executor.Run(cmd)
	if err == nil {
		return nil, fmt.Errorf("expected failure when listing versions")
	}

	output := stderr.String()
	// Parse available versions from error message
	versions := []string{}
	prefix := "(from versions:"
	suffix := ")"
	start := strings.Index(output, prefix)
	if start == -1 {
		return nil, fmt.Errorf("failed to parse available versions")
	}
	start += len(prefix)
	end := strings.Index(output[start:], suffix)
	if end == -1 {
		return nil, fmt.Errorf("failed to parse available versions")
	}
	versionStr := output[start : start+end]
	versionParts := strings.Split(versionStr, ",")
	for _, v := range versionParts {
		v = strings.TrimSpace(v)
		versions = append(versions, v)
	}
	return versions, nil
}

// GetTransitiveDependencies fetches transitive dependencies for a given dependency.
func (p *PythonPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	cmd := &core.Command{
		Name: "pipdeptree",
		Args: []string{"--json-tree"},
	}
	output, err := p.executor.Output(cmd)
	if err != nil {
		return nil, fmt.Errorf("failed to run pipdeptree: %v", err)
	}

	var tree []map[string]interface{}
	if err := json.Unmarshal(output, &tree); err != nil {
		return nil, fmt.Errorf("failed to parse pipdeptree output: %v", err)
	}

	var transDeps []core.Dependency
	for _, pkg := range tree {
		if pkg["package"].(map[string]interface{})["name"] == depName {
			dependencies, ok := pkg["dependencies"].([]interface{})
			if !ok {
				continue
			}
			for _, d := range dependencies {
				depMap, ok := d.(map[string]interface{})
				if !ok {
					continue
				}
				name := depMap["package"].(map[string]interface{})["name"].(string)
				version := depMap["package"].(map[string]interface{})["version"].(string)
				transDeps = append(transDeps, core.Dependency{
					Name:    name,
					Version: "=" + version,
				})
			}
			break
		}
	}

	return transDeps, nil
}

// RunSecurityScan runs security scans on installed Python packages using 'safety'.
func (p *PythonPlugin) RunSecurityScan() error {
	logrus.Info("Running security scan on Python dependencies using 'safety'...")
	// Install safety if not installed
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"install", "safety"},
	}
	if err := p.executor.Run(cmd); err != nil {
		return fmt.Errorf("failed to install 'safety': %v", err)
	}

	// Run safety check
	scanCmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"run", "safety", "check", "--json"},
	}
	scanOutput, err := p.executor.Output(scanCmd)
	if err != nil {
		return fmt.Errorf("security scan failed: %v", err)
	}

	var scanResults []core.SecurityVulnerability
	if err := json.Unmarshal(scanOutput, &scanResults); err != nil {
		return fmt.Errorf("failed to parse security scan results: %v", err)
	}

	if len(scanResults) > 0 {
		logrus.Warn("Vulnerabilities detected in Python dependencies:")
		for _, vuln := range scanResults {
			logrus.Warnf("- %s: %s", vuln.Package, vuln.Vulnerability)
		}
	} else {
		logrus.Info("No vulnerabilities found in Python dependencies.")
	}

	return nil
}

// GetVulnerabilities retrieves security vulnerabilities.
func (p *PythonPlugin) GetVulnerabilities() ([]core.SecurityVulnerability, error) {
	cmd := &core.Command{
		Name: p.getPipPath(),
		Args: []string{"run", "safety", "check", "--json"},
	}
	scanOutput, err := p.executor.Output(cmd)
	if err != nil {
		return nil, fmt.Errorf("security scan failed: %v", err)
	}

	var scanResults []core.SecurityVulnerability
	if err := json.Unmarshal(scanOutput, &scanResults); err != nil {
		return nil, fmt.Errorf("failed to parse security scan results: %v", err)
	}

	return scanResults, nil
}

// Cleanup cleans up Python plugin resources.
func (p *PythonPlugin) Cleanup() error {
	logrus.Info("Cleaning up Python plugin resources...")
	// Implement any necessary cleanup, such as removing virtual environments
	// For example:
	// return os.RemoveAll("venv")
	return nil
}
// plugins/rust/rust_plugin.go
package rust

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/sirupsen/logrus"
)

// Ensure the RustPlugin implements the PackageManagerPlugin interface.
var _ core.PackageManagerPlugin = (*RustPlugin)(nil)

// RustPlugin is the plugin for managing Rust dependencies.
type RustPlugin struct {
	executor core.Executor
}

// NewRustPlugin creates a new instance of RustPlugin with the given executor.
func NewRustPlugin(executor core.Executor) *RustPlugin {
	if executor == nil {
		executor = &core.RealExecutor{}
	}
	return &RustPlugin{
		executor: executor,
	}
}

// APIVersion returns the plugin API version.
func (p *RustPlugin) APIVersion() string {
	return core.PluginAPIVersion
}

// Language returns the name of the language this plugin manages.
func (p *RustPlugin) Language() string {
	return "rust"
}

// Initialize sets up the Rust plugin with necessary configurations.
func (p *RustPlugin) Initialize(config core.Config) error {
	logrus.Info("Initializing Rust plugin...")
	// Validate cargo installation
	if _, err := p.executor.Run(&core.Command{Name: "cargo", Args: []string{"--version"}}); err != nil {
		return fmt.Errorf("cargo is not installed or not in PATH")
	}
	// Ensure cargo-edit is installed
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"install", "cargo-edit"},
	}
	if err := p.executor.Run(cmd); err != nil {
		return fmt.Errorf("failed to install cargo-edit: %v", err)
	}
	// Ensure Cargo.toml exists; if not, initialize it
	_, err := p.executor.Output(&core.Command{
		Name: "cargo",
		Args: []string{"metadata", "--format-version", "1"},
	})
	if err != nil {
		logrus.Info("Cargo.toml not found. Initializing Cargo project...")
		cmd := &core.Command{
			Name: "cargo",
			Args: []string{"init"},
		}
		if err := p.executor.Run(cmd); err != nil {
			return fmt.Errorf("failed to initialize Cargo project: %v", err)
		}
	}
	return nil
}

// Install installs the specified Rust dependencies.
func (p *RustPlugin) Install(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Installing Rust package")

		// Add dependency to Cargo.toml
		if err := p.addDependencyToCargoToml(dep); err != nil {
			logrus.Errorf("Failed to add Rust package '%s' to Cargo.toml: %v", dep.Name, err)
			return err
		}

		// Run cargo build to fetch dependencies
		cmd := &core.Command{
			Name: "cargo",
			Args: []string{"build"},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to build Rust project after adding package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully installed Rust package: %s", dep.Name)
	}

	// Run security scans after installation.
	if err := p.RunSecurityScan(); err != nil {
		logrus.Warnf("Security scan encountered issues: %v", err)
	}

	return nil
}

// Update updates the specified Rust dependencies.
func (p *RustPlugin) Update(deps []core.Dependency) error {
	for _, dep := range deps {
		pkgStr := fmt.Sprintf("%s%s", dep.Name, dep.Version)
		logrus.WithFields(logrus.Fields{
			"dependency": dep.Name,
			"version":    dep.Version,
		}).Info("Updating Rust package")

		// Update dependency in Cargo.toml
		if err := p.updateDependencyInCargoToml(dep); err != nil {
			logrus.Errorf("Failed to update Rust package '%s' in Cargo.toml: %v", dep.Name, err)
			return err
		}

		// Run cargo update
		cmd := &core.Command{
			Name: "cargo",
			Args: []string{"update", "-p", dep.Name},
		}
		if err := p.executor.Run(cmd); err != nil {
			logrus.Errorf("Failed to update Rust package '%s': %v", dep.Name, err)
			return err
		}
		logrus.Infof("Successfully updated Rust package: %s", dep.Name)
	}

	// Run security scans after update.
	if err := p.RunSecurityScan(); err != nil {
		logrus.Warnf("Security scan encountered issues: %v", err)
	}

	return nil
}

// Remove removes the specified Rust dependency.
func (p *RustPlugin) Remove(dep core.Dependency) error {
	pkgStr := dep.Name
	logrus.WithFields(logrus.Fields{
		"dependency": dep.Name,
	}).Info("Removing Rust package")

	// Remove dependency from Cargo.toml
	if err := p.removeDependencyFromCargoToml(dep); err != nil {
		logrus.Errorf("Failed to remove Rust package '%s' from Cargo.toml: %v", dep.Name, err)
		return err
	}

	// Run cargo build to update dependencies
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"build"},
	}
	if err := p.executor.Run(cmd); err != nil {
		logrus.Errorf("Failed to build Rust project after removing package '%s': %v", dep.Name, err)
		return err
	}
	logrus.Infof("Successfully removed Rust package: %s", dep.Name)

	return nil
}

// List lists all installed Rust dependencies.
func (p *RustPlugin) List() ([]core.Dependency, error) {
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"tree", "--no-dev"},
	}
	output, err := p.executor.Output(cmd)
	if err != nil {
		return nil, err
	}

	// Parse the cargo tree output to list dependencies
	deps := []core.Dependency{}
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "├─") || strings.HasPrefix(line, "└─") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				pkgInfo := parts[1]
				pkgParts := strings.Split(pkgInfo, " ")
				if len(pkgParts) == 2 {
					deps = append(deps, core.Dependency{
						Name:    pkgParts[0],
						Version: "=" + pkgParts[1],
					})
				}
			}
		}
	}

	return deps, nil
}

// ListVersions lists all available versions for a given Rust package.
func (p *RustPlugin) ListVersions(depName string) ([]string, error) {
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"search", depName, "--limit", "100"},
	}
	output, err := p.executor.Output(cmd)
	if err != nil {
		return nil, err
	}

	// Parse cargo search output to get versions
	// Cargo search format: name = "description" [version]
	versions := []string{}
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.Contains(line, depName) {
			// Extract version using simple string manipulation
			parts := strings.Split(line, " ")
			for _, part := range parts {
				if strings.HasPrefix(part, "v") {
					versions = append(versions, part)
				}
			}
		}
	}

	return versions, nil
}

// GetTransitiveDependencies fetches transitive dependencies for a given dependency.
// Rust handles transitive dependencies automatically, so this can be a no-op.
func (p *RustPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	// Rust handles transitive dependencies automatically, so return nil
	return nil, nil
}

// RunSecurityScan runs security scans on installed Rust packages using 'cargo audit'.
func (p *RustPlugin) RunSecurityScan() error {
	logrus.Info("Running security scan on Rust dependencies using 'cargo audit'...")
	// Ensure cargo-audit is installed
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"install", "cargo-audit"},
	}
	if err := p.executor.Run(cmd); err != nil {
		return fmt.Errorf("failed to install cargo-audit: %v", err)
	}

	// Run cargo audit
	scanCmd := &core.Command{
		Name: "cargo",
		Args: []string{"audit", "--json"},
	}
	scanOutput, err := p.executor.Output(scanCmd)
	if err != nil {
		return fmt.Errorf("security scan failed: %v", err)
	}

	var auditResults []core.SecurityVulnerability
	if err := json.Unmarshal(scanOutput, &auditResults); err != nil {
		return fmt.Errorf("failed to parse cargo audit output: %v", err)
	}

	if len(auditResults) > 0 {
		logrus.Warn("Vulnerabilities detected in Rust dependencies:")
		for _, vuln := range auditResults {
			logrus.Warnf("- %s: %s", vuln.Package, vuln.Vulnerability)
		}
	} else {
		logrus.Info("No vulnerabilities found in Rust dependencies.")
	}

	return nil
}

// GetVulnerabilities retrieves security vulnerabilities.
func (p *RustPlugin) GetVulnerabilities() ([]core.SecurityVulnerability, error) {
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"audit", "--json"},
	}
	scanOutput, err := p.executor.Output(cmd)
	if err != nil {
		return nil, fmt.Errorf("security scan failed: %v", err)
	}

	var auditResults []core.SecurityVulnerability
	if err := json.Unmarshal(scanOutput, &auditResults); err != nil {
		return nil, fmt.Errorf("failed to parse cargo audit output: %v", err)
	}

	return auditResults, nil
}

// Cleanup cleans up Rust plugin resources.
func (p *RustPlugin) Cleanup() error {
	logrus.Info("Cleaning up Rust plugin resources...")
	// Implement any necessary cleanup
	return nil
}

// runGoModTidy runs 'go mod tidy' to clean up dependencies.
func (p *RustPlugin) runGoModTidy() error {
	cmd := &core.Command{
		Name: "go",
		Args: []string{"mod", "tidy"},
	}
	return p.executor.Run(cmd)
}

// addDependencyToCargoToml adds a dependency to Cargo.toml
func (p *RustPlugin) addDependencyToCargoToml(dep core.Dependency) error {
	// Add dependency using cargo-edit
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"add", fmt.Sprintf("%s=%s", dep.Name, strings.TrimPrefix(dep.Version, "^"))},
	}
	return p.executor.Run(cmd)
}

// updateDependencyInCargoToml updates a dependency in Cargo.toml
func (p *RustPlugin) updateDependencyInCargoToml(dep core.Dependency) error {
	// Update dependency using cargo-edit
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"upgrade", dep.Name},
	}
	return p.executor.Run(cmd)
}

// removeDependencyFromCargoToml removes a dependency from Cargo.toml
func (p *RustPlugin) removeDependencyFromCargoToml(dep core.Dependency) error {
	// Remove dependency using cargo-edit
	cmd := &core.Command{
		Name: "cargo",
		Args: []string{"remove", dep.Name},
	}
	return p.executor.Run(cmd)
}
// tests/core/config_test.go
package core_test

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/GH-Solutions-Consultants/Paxly/core"
)

func TestConfig_Validate_Success(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:        "TestProject",
			Version:     "1.0.0",
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "john.doe@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{
			"development": {
				Dependencies: map[string][]core.Dependency{
					"python": {
						{
							Name:    "requests",
							Version: "^2.28",
						},
					},
					"javascript": {
						{
							Name:    "express",
							Version: "^4.17.1",
						},
					},
				},
			},
			"production": {
				Dependencies: map[string][]core.Dependency{
					"python": {
						{
							Name:    "requests",
							Version: "^2.28",
						},
					},
					"javascript": {
						{
							Name:    "express",
							Version: "^4.17.1",
						},
					},
					"go": {
						{
							Name:    "github.com/gin-gonic/gin",
							Version: "^1.7.4",
						},
					},
					"rust": {
						{
							Name:    "serde",
							Version: "^1.0",
						},
					},
				},
			},
		},
		TrustedSources: map[string][]string{
			"python":      {"https://pypi.org/simple"},
			"javascript":  {"https://registry.npmjs.org/"},
			"go":          {"https://proxy.golang.org/"},
			"rust":        {"https://crates.io/"},
		},
	}

	err := config.Validate()
	assert.NoError(t, err, "Expected configuration to be valid")
}

func TestConfig_Validate_MissingProjectName(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			// Name is missing
			Version:     "1.0.0",
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "john.doe@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{},
		TrustedSources: map[string][]string{
			"python": {"https://pypi.org/simple"},
		},
	}

	err := config.Validate()
	assert.Error(t, err, "Expected configuration to fail validation due to missing project name")
}

func TestConfig_Validate_InvalidProjectVersion(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:        "TestProject",
			Version:     "invalid_version", // Invalid semantic version
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "john.doe@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{},
		TrustedSources: map[string][]string{
			"python": {"https://pypi.org/simple"},
		},
	}

	err := config.Validate()
	assert.Error(t, err, "Expected configuration to fail validation due to invalid project version")
}

func TestConfig_Validate_InvalidAuthorEmail(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:        "TestProject",
			Version:     "1.0.0",
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "invalid-email", // Invalid email format
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{},
		TrustedSources: map[string][]string{
			"python": {"https://pypi.org/simple"},
		},
	}

	err := config.Validate()
	assert.Error(t, err, "Expected configuration to fail validation due to invalid author email")
}

func TestConfig_Validate_InvalidTrustedSourceURL(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:        "TestProject",
			Version:     "1.0.0",
			Description: "A test project",
			Authors: []core.Author{
				{
					Name:  "John Doe",
					Email: "john.doe@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{},
		TrustedSources: map[string][]string{
			"python": {"invalid-url"}, // Invalid URL
		},
	}

	err := config.Validate()
	assert.Error(t, err, "Expected configuration to fail validation due to invalid trusted source URL")
}

func TestDependency_Validate_Success(t *testing.T) {
	dep := core.Dependency{
		Name:    "requests",
		Version: "^2.28",
	}

	err := dep.Validate()
	assert.NoError(t, err, "Expected dependency validation to pass")
	assert.NotNil(t, dep.Constraint, "Expected Constraint to be parsed")
}

func TestDependency_Validate_InvalidVersion(t *testing.T) {
	dep := core.Dependency{
		Name:    "requests",
		Version: "invalid_version",
	}

	err := dep.Validate()
	assert.Error(t, err, "Expected dependency validation to fail due to invalid version")
}

func TestDependency_Validate_MissingName(t *testing.T) {
	dep := core.Dependency{
		// Name is missing
		Version: "^2.28",
	}

	err := dep.Validate()
	assert.Error(t, err, "Expected dependency validation to fail due to missing name")
}

func TestDependency_Validate_MissingVersion(t *testing.T) {
	dep := core.Dependency{
		Name:    "requests",
		Version: "", // Missing version
	}

	err := dep.Validate()
	assert.Error(t, err, "Expected dependency validation to fail due to missing version")
}
// tests/core/resolver_test.go
package core_test

import (
	"testing"

	"github.com/go-playground/validator/v10"
	"github.com/stretchr/testify/assert"
	"github.com/GH-Solutions-Consultants/Paxly/core"
)

func TestResolver_ResolveDependencies_NoConflicts(t *testing.T) {
	config := core.Config{
		Project: core.ProjectConfig{
			Name:    "TestProject",
			Version: "1.0.0",
			Authors: []core.Author{
				{
					Name:  "Tester",
					Email: "tester@example.com",
				},
			},
		},
		Environments: map[string]core.EnvironmentConfig{
			"development": {
				Dependencies: map[string][]core.Dependency{
					"python": {
						{
							Name:    "requests",
							Version: "^2.28",
						},
					},
					"javascript": {
						{
							Name:    "express",
							Version: "^4.17.1",
						},
					},
				},
			},
		},
		TrustedSources: map[string][]string{
			"python":      {"https://pypi.org/simple"},
			"javascript":  {"https://registry.npmjs.org/"},
			"go":          {"https://proxy.golang.org/"},
			"rust":        {"https://crates.io/"},
		},
	}

	// Validate config
	validate := validator.New()
	err := validate.Struct(config)
	assert.NoError(t, err)

	// Initialize Plugin Registry with mock plugins
	pr := core.NewPluginRegistry()
	pr.RegisterPlugin(&MockPythonPlugin{})
	pr.RegisterPlugin(&MockJavaScriptPlugin{})

	// Initialize Resolver
	resolver := core.NewResolver(config, pr)
	resolvedVersions, err := resolver.ResolveDependencies("development")
	assert.NoError(t, err, "ResolveDependencies should not return an error")

	// Verify resolved dependencies
	expected := map[string]string{
		"requests": "2.28.1",
		"express":  "4.17.1",
	}
	for name, version := range expected {
		resolvedVersion, exists := resolvedVersions[name]
		assert.True(t, exists, "Dependency '%s' should be resolved", name)
		assert.Equal(t, version, resolvedVersion, "Version mismatch for '%s'", name)
	}
}

// Mock Plugins for Testing
type MockPythonPlugin struct{}

func (p *MockPythonPlugin) APIVersion() string        { return core.PluginAPIVersion }
func (p *MockPythonPlugin) Language() string          { return "python" }
func (p *MockPythonPlugin) Initialize(config core.Config) error { return nil }
func (p *MockPythonPlugin) Install(deps []core.Dependency) error { return nil }
func (p *MockPythonPlugin) Update(deps []core.Dependency) error { return nil }
func (p *MockPythonPlugin) Remove(dep core.Dependency) error { return nil }
func (p *MockPythonPlugin) List() ([]core.Dependency, error) { return nil, nil }
func (p *MockPythonPlugin) ListVersions(depName string) ([]string, error) {
	return []string{"2.28.0", "2.28.1"}, nil
}
func (p *MockPythonPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	return nil, nil
}
func (p *MockPythonPlugin) Cleanup() error { return nil }

type MockJavaScriptPlugin struct{}

func (p *MockJavaScriptPlugin) APIVersion() string        { return core.PluginAPIVersion }
func (p *MockJavaScriptPlugin) Language() string          { return "javascript" }
func (p *MockJavaScriptPlugin) Initialize(config core.Config) error { return nil }
func (p *MockJavaScriptPlugin) Install(deps []core.Dependency) error { return nil }
func (p *MockJavaScriptPlugin) Update(deps []core.Dependency) error { return nil }
func (p *MockJavaScriptPlugin) Remove(dep core.Dependency) error { return nil }
func (p *MockJavaScriptPlugin) List() ([]core.Dependency, error) { return nil, nil }
func (p *MockJavaScriptPlugin) ListVersions(depName string) ([]string, error) {
	return []string{"4.17.0", "4.17.1"}, nil
}
func (p *MockJavaScriptPlugin) GetTransitiveDependencies(depName, version string) ([]core.Dependency, error) {
	return nil, nil
}
func (p *MockJavaScriptPlugin) Cleanup() error { return nil }
// tests/plugins/python_plugin_test.go
package plugins_test

import (
	"errors"
	"testing"
	"github.com/stretchr/testify/assert"
	"github.com/GH-Solutions-Consultants/Paxly/core"
	"github.com/GH-Solutions-Consultants/Paxly/plugins/python"

// MockExecutor is a mock for executing commands.
type MockExecutor struct {
	mock.Mock
}

func (m *MockExecutor) Run(cmd *core.Command) error {
	args := m.Called(cmd)
	return args.Error(0)
}

func (m *MockExecutor) Output(cmd *core.Command) ([]byte, error) {
	args := m.Called(cmd)
	return args.Get(0).([]byte), args.Error(1)
}

func TestPythonPlugin_Install_Success(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(nil).Twice() // create venv and install pipdeptree
	mockExec.On("Run", mock.Anything).Return(nil)            // pip install

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Define dependencies to install
	deps := []core.Dependency{
		{
			Name:    "requests",
			Version: "^2.28",
		},
	}

	// Execute Install
	err := plugin.Install(deps)
	assert.NoError(t, err, "Expected Install to succeed")

	// Assert that Run was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_Install_Failure(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(errors.New("pip install failed"))

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Define dependencies to install
	deps := []core.Dependency{
		{
			Name:    "requests",
			Version: "^2.28",
		},
	}

	// Execute Install
	err := plugin.Install(deps)
	assert.Error(t, err, "Expected Install to fail")

	// Assert that Run was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_List_Success(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Sample pip freeze output
	pipFreezeOutput := []byte("requests==2.28.1\nflask==1.1.2\n")

	// Setup expected commands and their outcomes
	mockExec.On("Output", mock.Anything).Return(pipFreezeOutput, nil)

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute List
	deps, err := plugin.List()
	assert.NoError(t, err, "Expected List to succeed")
	assert.Len(t, deps, 2, "Expected two dependencies listed")

	assert.Equal(t, "requests", deps[0].Name)
	assert.Equal(t, "=2.28.1", deps[0].Version)

	assert.Equal(t, "flask", deps[1].Name)
	assert.Equal(t, "=1.1.2", deps[1].Version)

	// Assert that Output was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_List_Failure(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Setup expected commands and their outcomes
	mockExec.On("Output", mock.Anything).Return(nil, errors.New("pip freeze failed"))

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute List
	deps, err := plugin.List()
	assert.Error(t, err, "Expected List to fail")
	assert.Nil(t, deps, "Expected no dependencies returned on failure")

	// Assert that Output was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_ListVersions_Success(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Mocked available versions
	availableVersions := []string{"2.25.0", "2.25.1", "2.26.0", "2.28.1"}

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(nil) // pip install failed as expected
	mockExec.On("Run", mock.Anything).Return(nil)
	mockExec.On("Output", mock.Anything).Return([]byte{}, nil) // Simplified

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute ListVersions
	versions, err := plugin.ListVersions("requests")
	assert.NoError(t, err, "Expected ListVersions to succeed")
	assert.Equal(t, availableVersions, versions, "Expected list of available versions")

	// Assert that Run was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_GetTransitiveDependencies_Success(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Sample pipdeptree JSON output
	pipDeptreeOutput := []byte(`[
		{
			"package": {"key": "requests", "name": "requests", "version": "2.28.1"},
			"dependencies": [
				{
					"package": {"key": "urllib3", "name": "urllib3", "version": "1.26.5"},
					"dependencies": []
				}
			]
		}
	]`)

	// Setup expected commands and their outcomes
	mockExec.On("Output", mock.Anything).Return(pipDeptreeOutput, nil)

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute GetTransitiveDependencies
	transDeps, err := plugin.GetTransitiveDependencies("requests", "^2.28")
	assert.NoError(t, err, "Expected GetTransitiveDependencies to succeed")
	assert.Len(t, transDeps, 1, "Expected one transitive dependency")

	assert.Equal(t, "urllib3", transDeps[0].Name)
	assert.Equal(t, "=1.26.5", transDeps[0].Version)

	// Assert that Output was called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_RunSecurityScan_NoVulnerabilities(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Sample safety check output with no vulnerabilities
	safetyOutput := []byte("[]")

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(nil).Twice() // pip install safety and run safety check
	mockExec.On("Output", mock.Anything).Return(safetyOutput, nil)

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute RunSecurityScan
	err := plugin.RunSecurityScan()
	assert.NoError(t, err, "Expected RunSecurityScan to pass with no vulnerabilities")

	// Assert that Run and Output were called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_RunSecurityScan_WithVulnerabilities(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Sample safety check output with vulnerabilities
	safetyOutput := []byte(`[{"package": "requests", "vulnerability": "CVE-XXXX-XXXX"}]`)

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(nil).Twice() // pip install safety and run safety check
	mockExec.On("Output", mock.Anything).Return(safetyOutput, nil)

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute RunSecurityScan
	err := plugin.RunSecurityScan()
	assert.NoError(t, err, "Expected RunSecurityScan to complete even with vulnerabilities")

	// Assert that Run and Output were called
	mockExec.AssertExpectations(t)
}

func TestPythonPlugin_RunSecurityScan_Failure(t *testing.T) {
	// Initialize the mock executor
	mockExec := new(MockExecutor)

	// Setup expected commands and their outcomes
	mockExec.On("Run", mock.Anything).Return(errors.New("safety install failed"))

	// Initialize the PythonPlugin with the mock executor
	plugin := python.NewPythonPlugin(mockExec)

	// Execute RunSecurityScan
	err := plugin.RunSecurityScan()
	assert.Error(t, err, "Expected RunSecurityScan to fail due to safety install error")

	// Assert that Run was called
	mockExec.AssertExpectations(t)
}
